@page "/migrationjobviewer/{jobId}"
@using OnlineMongoMigrationProcessor
@using MongoMigrationWebApp.Components
@using MongoMigrationWebApp.Helpers
@using OnlineMongoMigrationProcessor.Helpers
@using MigrationJobType = OnlineMongoMigrationProcessor.MigrationJob
@inject Service.JobManager JobManager
@inject NavigationManager NavigationManager
@inject IJSRuntime JS
@inject Service.FileService FileService
@inject HttpClient HttpClient
@implements IDisposable

<div class="d-flex justify-content-between align-items-center mb-3">
    <h3>
        <button class="btn btn-light" @onclick="GoBack" title="Back to Job List" style="border: none; background: transparent;">
            <i class="bi bi-arrow-left"></i>
        </button>
        @MigrationJob?.Name - Job Status
    </h3>
    <div class="d-flex align-items-center mb-3">

        @if (IsResumeEnabled() && !_isLoadingCollections)
        {
            <div class="btn-group mx-2">
                <button class="btn btn-primary dropdown-toggle" type="button" id="resumeJobDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Resume Job
                </button>
                <ul class="dropdown-menu" aria-labelledby="resumeJobDropdown">
                    <li><a class="dropdown-item" @onclick="ResumeJobWithNewConnectionString">With Updated Connection Strings</a></li>
                    @if (MigrationJob != null && !string.IsNullOrEmpty(MigrationJobContext.SourceConnectionString[MigrationJob.Id]) && !string.IsNullOrEmpty(MigrationJobContext.TargetConnectionString[MigrationJob.Id]))
                    {
                        <li><a class="dropdown-item" @onclick="ResumeJobWithExistingConnectionString">With Existing Connection Strings</a></li>
                    }
                </ul>
            </div>
        }

        @if (IsPauseEnabled() && !_isLoadingCollections)
        {
            @* Pause Job - with dropdown for controlled pause if applicable *@
            @if (MigrationJob != null && JobManager.IsControlledPauseApplicable(MigrationJob.JobType, MigrationJob))
            {
                <div class="btn-group mx-2">
                    <button class="btn btn-primary dropdown-toggle" type="button" id="pauseJobDropdown" data-bs-toggle="dropdown" aria-expanded="false" title="Choose pause method">
                        Pause Job
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="pauseJobDropdown">
                        <li><a class="dropdown-item" @onclick="PauseJobControlled" title="Stops accepting new chunks but allows active chunks to complete"><i class="bi bi-pause-circle"></i> Controlled Pause (Graceful)</a></li>
                        <li><a class="dropdown-item" @onclick="PauseJobImmediate" title="Immediately cancels all operations"><i class="bi bi-stop-circle"></i> Immediate Stop</a></li>
                    </ul>
                </div>
            }
            else
            {
                <button class="btn btn-primary mx-2" title="Pause Job" @onclick="PauseJobImmediate">Pause Job</button>
            }
            
            @* Display controlled pause status *@
            @if (JobManager.IsControlledPauseRequested())
            {
                <span class="badge bg-warning text-dark mx-2" title="Controlled pause in progress - waiting for active chunks to complete">
                    <i class="bi bi-hourglass-split"></i> Pausing...
                </span>
            }
            
            @* Worker adjustment dropdown - only for DumpAndRestore jobs with parallel processing enabled *@
            @if (MigrationJob?.JobType == OnlineMongoMigrationProcessor.Models.JobType.DumpAndRestore &&
                    MigrationJob?.EnableParallelProcessing == true && !CheckCutoverReadiness())
            {
                <div class="btn-group mx-2">
                    <button class="btn btn-outline-secondary dropdown-toggle" type="button" id="workerAdjustmentDropdown" data-bs-toggle="dropdown" aria-expanded="false" title="Adjust parallel processing workers. D=Dump processes, R=Restore processes, I=Insertion workers per restore process">
                        <i class="bi bi-speedometer2"></i> D:@(MigrationJob?.CurrentDumpWorkers ?? 0), R:@(MigrationJob?.CurrentRestoreWorkers ?? 0), I:@(MigrationJob?.CurrentInsertionWorkers ?? 0)
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="workerAdjustmentDropdown">
                        <li><a class="dropdown-item" @onclick="IncreaseDumpWorkers" title="Increase the number of parallel mongodump processes to speed up data extraction from source"><i class="bi bi-plus-circle"></i> Dump Instances</a></li>
                        <li><a class="dropdown-item" @onclick="DecreaseDumpWorkers" title="Decrease the number of parallel mongodump processes to reduce load on source"><i class="bi bi-dash-circle"></i> Dump Instances</a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" @onclick="IncreaseRestoreWorkers" title="Increase the number of parallel mongorestore processes to speed up data insertion to target"><i class="bi bi-plus-circle"></i> Restore Instances</a></li>
                        <li><a class="dropdown-item" @onclick="DecreaseRestoreWorkers" title="Decrease the number of parallel mongorestore processes to reduce load on target"><i class="bi bi-dash-circle"></i> Restore Instances</a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" @onclick="IncreaseInsertionWorkers" title="Increase the number of insertion threads per mongorestore process for faster document insertion"><i class="bi bi-plus-circle"></i> Insertion Workers</a></li>
                        <li><a class="dropdown-item" @onclick="DecreaseInsertionWorkers" title="Decrease the number of insertion threads per mongorestore process to reduce target database load"><i class="bi bi-dash-circle"></i> Insertion Workers</a></li>
                    </ul>
                </div>
            }
            @if (MigrationJob != null && Helper.IsOnline(MigrationJob) && MigrationJob.SyncBackEnabled && !MigrationJob.ProcessingSyncBack)
            {
                <button class="btn btn-warning dropdown-toggle" title="Perform Cut Over" disabled="@(!CheckCutoverReadiness())" data-bs-toggle="dropdown" aria-expanded="false">Cut Over</button>

                <ul class="dropdown-menu" aria-labelledby="performCutOverDropdown">
                    <li><a class="dropdown-item" @onclick="InitSyncBackJob">With Sync Back</a></li>
                    <li><a class="dropdown-item" @onclick="CompleteJob">Without Sync Back</a></li>

                </ul>
            }
            else if (MigrationJob != null && Helper.IsOnline(MigrationJob) && MigrationJob.SyncBackEnabled && MigrationJob.ProcessingSyncBack)
            {
                <button class="btn btn-warning" title="Complete Job" @onclick="CompleteJob">Complete Job</button>
            }
            else if (MigrationJob != null && Helper.IsOnline(MigrationJob) && !MigrationJob.SyncBackEnabled)
            {
                <button class="btn btn-warning" title="Perform Cut Over" disabled="@(!CheckCutoverReadiness())" @onclick="CompleteJob">Cut Over</button>
            }

            <button class="btn btn-toolbar" title="Refresh" @onclick="Refresh">
                <i class="bi bi-arrow-repeat"></i>
            </button>

            <button class="btn btn-sm @((MigrationJob?.AutoRefreshEnabled ?? true) ? "btn-outline-success" : "btn-outline-secondary") ms-2" 
                    @onclick="ToggleAutoRefresh" 
                    title="@((MigrationJob?.AutoRefreshEnabled ?? true) ? "Auto-refresh is ON - Click to pause UI updates" : "Auto-refresh is OFF - Click to resume UI updates")"
                    style="border: 1px solid;">
                <i class="bi @((MigrationJob?.AutoRefreshEnabled ?? true) ? "bi-play-fill" : "bi-pause-fill")"></i>
            </button>
        }

    </div>
</div>


@if (!string.IsNullOrEmpty(_errorMessage))
{
    <div class="alert alert-danger mt-2">
        @_errorMessage
        <button type="button" class="btn-close btn-close-sm" aria-label="Close" @onclick="() => _errorMessage = string.Empty"></button>
    </div>
}


@if (_migrationDetailsPopUpOpen && MigrationJob != null)
{
    <MongoMigrationWebApp.Components.MigrationDetails NewMode=false
                                                      Job="@MigrationJob"
                                                      OnSubmit="@OnMigrationDetailsPopUpSubmit"
                                                      CheckNameExists="CheckIfNameExistsAsync" />
}

@if (_yesNoDialogOpen)
{
   <YesNoDialog Type=_yesNoDiaLogType Caption="Confirmation Required" Message="@_message" OnClose="@YesNoDialogSubmit" />
}
@if (_manageCollectionDialogOpen && MigrationJob != null)
{
    <ManageCollections MigrationJob="@MigrationJob" MigrationUnits="@JobManager.GetMigrationUnits(MigrationJob)" SourceConnectionString="@MigrationJobContext.SourceConnectionString[MigrationJob.Id]" OnCollectionsUpdated="@OnCollectionsUpdated" />
}

@if (_resetChangeStreamDialogOpen && MigrationJob != null)
{
    <ResetChangeStream MigrationUnits="@((@JobManager.GetMigrationUnits(MigrationJob) ?? new List<MigrationUnit>()).Where(mu => Helper.IsMigrationUnitValid(mu)).ToList())" OnCollectionsUpdated="@OnCSReset" />
}
@if (_collectionDetailsDialogOpen && _selectedMigrationUnit != null)
{
    <CollectionDetails MigrationJob="@MigrationJob" MigrationUnit="@JobManager.GetMigrationUnits(MigrationJob).Find(mu => mu.Id == _selectedMigrationUnit.Id)" OnClose="HandleCollectionDetailsClose" />
}

@* Collections Loading Spinner *@
@if (_isLoadingCollections)
{
    <div class="d-flex justify-content-center align-items-center my-4">
        <div class="text-center">
            <div class="spinner-border text-primary mb-3" role="status" aria-hidden="true" style="width: 3rem; height: 3rem;">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div>
                <h5>Loading Collections...</h5>
                <p class="text-muted">Please wait while we discover and load the collections from your database.</p>
            </div>
        </div>
    </div>
}

@* Collections Filter and Pagination Controls *@
@if (MigrationJob.MigrationUnitBasics != null && MigrationJob.MigrationUnitBasics.Count > 0 && !_isLoadingCollections)
{
    <div class="collections-filter-section">
        <div class="row">
            <div class="col-md-8">
                <div class="input-group filter-input-group">
                    <span class="input-group-text"><i class="bi bi-search"></i></span>
                    <input type="text" class="form-control" placeholder="Filter collections by any column (database, collection, status, etc.)" 
                           @bind="_filterText" @bind:event="oninput" @onkeyup="OnFilterChanged" />
                    @if (!string.IsNullOrWhiteSpace(_filterText))
                    {
                        <button class="btn btn-outline-secondary filter-clear-btn" type="button" @onclick="ClearFilter" title="Clear filter">
                            <i class="bi bi-x"></i>
                        </button>
                    }
                </div>
            </div>
            <div class="col-md-4">
                <div class="d-flex justify-content-end">
                    <div class="page-size-selector-top">
                        <select id="pageSizeSelect" class="form-select form-select-sm page-size-dropdown" @bind="_pageSize" @bind:after="OnPageSizeChanged" style="width: auto;" title="Items per page">
                            <option value="10">10 per page</option>
                            <option value="25">25 per page</option>
                            <option value="50">50 per page</option>
                            <option value="100">100 per page</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

<div class="collections-table-wrapper">
    <table class="table collections-table">
        <thead>
            <tr>
                <th class="sortable-header @GetSortClass("DatabaseName")" @onclick='() => SortBy("DatabaseName")' style="cursor: pointer;">
                    Database Name
                    <i class="bi @GetSortIcon("DatabaseName") ms-1"></i>
                </th>
                <th class="sortable-header @GetSortClass("CollectionName")" @onclick='() => SortBy("CollectionName")' style="cursor: pointer;">
                    Collection Name
                    <i class="bi @GetSortIcon("CollectionName") ms-1"></i>
                </th>
                @if (MigrationJob != null && MigrationJob.JobType==OnlineMongoMigrationProcessor.Models.JobType.DumpAndRestore)
                {
                    <th class="sortable-header @GetSortClass("DownloadStatus")" @onclick='() => SortBy("DownloadStatus")' style="cursor: pointer;">
                        Download Status
                        <i class="bi @GetSortIcon("DownloadStatus") ms-1"></i>
                    </th>
                    <th class="sortable-header @GetSortClass("UploadStatus")" @onclick='() => SortBy("UploadStatus")' style="cursor: pointer;">
                        Upload Status
                        <i class="bi @GetSortIcon("UploadStatus") ms-1"></i>
                    </th>
                }
                else
                {
                    <th class="sortable-header @GetSortClass("CopyStatus")" @onclick='() => SortBy("CopyStatus")' style="cursor: pointer;">
                        Copy Status
                        <i class="bi @GetSortIcon("CopyStatus") ms-1"></i>
                    </th>
                }
                @if (MigrationJob != null && Helper.IsOnline(MigrationJob) && !MigrationJob.ProcessingSyncBack)
                {
                    @if (MigrationJob.JobType != OnlineMongoMigrationProcessor.Models.JobType.RUOptimizedCopy)
                    {
                        <th class="sortable-header @GetSortClass("TimeSinceLastChange")" @onclick='() => SortBy("TimeSinceLastChange")' style="cursor: pointer;">
                            Time Since Last Change
                            <i class="bi @GetSortIcon("TimeSinceLastChange") ms-1"></i>
                        </th>
                        <th class="sortable-header @GetSortClass("LastBatchChanges")" @onclick='() => SortBy("LastBatchChanges")' style="cursor: pointer;">
                            Last Batch – Total Changes
                            <i class="bi @GetSortIcon("LastBatchChanges") ms-1"></i>
                        </th>
                    }
                    else
                    {
                        <th class="sortable-header @GetSortClass("LastBatchChanges")" @onclick='() => SortBy("LastBatchChanges")' style="cursor: pointer;">
                            Change Stream Last Batch – Total Changes
                            <i class="bi @GetSortIcon("LastBatchChanges") ms-1"></i>
                        </th>
                    }

                }
                @if (MigrationJob != null && Helper.IsOnline(MigrationJob) && MigrationJob.ProcessingSyncBack)
                {

                     <th class="sortable-header @GetSortClass("TimeSinceLastChange")" @onclick='() => SortBy("TimeSinceLastChange")' style="cursor: pointer;">
                        Time Since Last Sync Back
                        <i class="bi @GetSortIcon("TimeSinceLastChange") ms-1"></i>
                    </th>
                    <th class="sortable-header @GetSortClass("LastBatchChanges")" @onclick='() => SortBy("LastBatchChanges")' style="cursor: pointer;">
                        Last Batch – Total Changes
                        <i class="bi @GetSortIcon("LastBatchChanges") ms-1"></i>
                    </th>
                }
            </tr>
        </thead>
        <tbody>
            @if (!_isLoadingCollections && MigrationJob.MigrationUnitBasics != null && GetFilteredAndPagedUnits().Any())
            {
                @foreach (var mu in GetFilteredAndPagedUnits())
                {
                    <tr>
                        <td>
                            <i class="bi bi-info-circle-fill me-2 collection-info-icon" title="More info" style="cursor: pointer;"
                               @onclick="() => ShowCollectionDetails(mu)"></i>
                            @mu.DatabaseName
                        </td>
                        <td>@mu.CollectionName</td>
                        <td>
                            @(mu.SourceStatus == CollectionStatus.NotFound ? "Skipped (404)"
                                                : mu.SourceStatus == CollectionStatus.IsView ? "Skipped (VIEW)"
                                                : (mu.DumpComplete ? "Success" : $"{mu.DumpPercent:F1}%"))

                        </td>

                        @if (MigrationJob != null && MigrationJob.JobType == OnlineMongoMigrationProcessor.Models.JobType.DumpAndRestore)
                        {
                            <td>
                                @(mu.SourceStatus == CollectionStatus.NotFound ? "Skipped (404)"
                                                    : mu.SourceStatus == CollectionStatus.IsView ? "Skipped (VIEW)"
                                                    : (mu.RestoreComplete || mu.RestorePercent == 100 ? "Success" : $"{mu.RestorePercent:F1}%"))

                            </td>
                        }
                        @if (MigrationJob != null && Helper.IsOnline(MigrationJob))
                        {
                            @if (MigrationJob.JobType != OnlineMongoMigrationProcessor.Models.JobType.RUOptimizedCopy || MigrationJob.ProcessingSyncBack)
                            {
                                <td>                           
                                   @Helper.GetChangeStreamLag(mu, MigrationJob.ProcessingSyncBack)                            
                                </td>
                            }
                            <td>
                                @mu.CSUpdatesInLastBatch
                            </td>
                        }
                    </tr>
                }
            }
            else if (!_isLoadingCollections && @MigrationJob.MigrationUnitBasics!= null && !string.IsNullOrWhiteSpace(_filterText))
            {
                <tr>
                    <td colspan="10" class="empty-collections-state">
                        <i class="bi bi-search"></i>
                        <h5>No collections match your filter</h5>
                        <p>Try adjusting your search terms or <button class="btn btn-link p-0" @onclick="ClearFilter">clear the filter</button></p>
                    </td>
                </tr>
            }
            else if (!_isLoadingCollections && (@MigrationJob.MigrationUnitBasics == null || !@MigrationJob.MigrationUnitBasics.Any()))
            {
                <tr>
                    <td colspan="10" class="empty-collections-state">
                        <i class="bi bi-collection"></i>
                        <h5>No collections configured</h5>
                        <p>Use the "Update Collections" button below to add collections to this migration job.</p>
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

@* Pagination Controls *@
@if (!_isLoadingCollections && GetTotalPages() > 1)
{
    <nav aria-label="Collections pagination" class="mt-3">
        <ul class="pagination justify-content-center">
            <li class="page-item @(IsFirstPage() ? "disabled" : "")">
                <button class="page-link" @onclick="() => GoToPage(1)" disabled="@IsFirstPage()" title="First page">
                    <i class="bi bi-chevron-double-left"></i>
                </button>
            </li>
            <li class="page-item @(IsFirstPage() ? "disabled" : "")">
                <button class="page-link" @onclick="() => GoToPage(_currentPage - 1)" disabled="@IsFirstPage()" title="Previous page">
                    <i class="bi bi-chevron-left"></i>
                </button>
            </li>

            @for (int page = GetStartPage(); page <= GetEndPage(); page++)
            {
                var pageNumber = page;
                <li class="page-item @(_currentPage == pageNumber ? "active" : "")">
                    <button class="page-link" @onclick="() => GoToPage(pageNumber)" title="Go to page @pageNumber">
                        @pageNumber
                    </button>
                </li>
            }

            <li class="page-item @(IsLastPage() ? "disabled" : "")">
                <button class="page-link" @onclick="() => GoToPage(_currentPage + 1)" disabled="@IsLastPage()" title="Next page">
                    <i class="bi bi-chevron-right"></i>
                </button>
            </li>
            <li class="page-item @(IsLastPage() ? "disabled" : "")">
                <button class="page-link" @onclick="() => GoToPage(GetTotalPages())" disabled="@IsLastPage()" title="Last page">
                    <i class="bi bi-chevron-double-right"></i>
                </button>
            </li>
        </ul>
        
        <div class="text-center mt-2">
            <small class="text-muted">
                Page @_currentPage of @GetTotalPages() 
                (@GetFilteredItemsCount() @(GetFilteredItemsCount() == 1 ? "collection" : "collections"))
            </small>
        </div>
    </nav>
}

@if(!_isLoadingCollections)
{
    <div class="d-flex align-items-center mb-3 mt-4">
        <button class="btn btn-primary mx-2" title="You can add or remove collections from this job. Be sure to pause the job before doing so." @onclick="ManageCollections" disabled="@_isLoadingCollections">Update Collections</button>
        @if (MigrationJob != null && Helper.IsOnline(MigrationJob))
        {
            <button class="btn btn-warning mx-2" title="Reset the change stream checkpoint to start from the beginning. This may add extra load to the migration process and could delay other collections. Ensure the job is paused before continuing." @onclick="ResetChangeStream">
                @(((@MigrationJob.MigrationUnitBasics ?? new List<MigrationUnitBasic>()).Any(MigrationUnit => MigrationUnit.ResetChangeStream)) ? "✓ Reset Change Stream" : "☐ Reset Change Stream")
            </button>

            @if (MigrationJob?.JobType != OnlineMongoMigrationProcessor.Models.JobType.RUOptimizedCopy)
            {
                <button class="btn btn-warning mx-2" title="Compare randomly selected documents from collections in the source and target accounts to identify any discrepancies or missing entries. Be sure to pause the job before doing so." @onclick="RunComparison">
                    @((MigrationJob?.RunComparison ?? false) ? "✓ Run Hash Check" : "☐ Run Hash Check")
                </button>
            }
        }
    
    </div>
}

@if ((MigrationJob?.AutoRefreshEnabled ?? true) && LogBucket != null && VerboseMessages != null && VerboseMessages.Count > 0 && !_showLogBackupFile)
{
    <h5 class="pt-4">
        Monitor
    </h5>
    <div>
        <table class="table message-output">
            <tbody>
                @foreach (var logObject in VerboseMessages)
                {
                    <tr>
                        <td>
                            @if(string.IsNullOrEmpty(logObject.Message))
                            {
                                <span>&nbsp;</span>
                            }
                            else
                            {
                                <span>@logObject.Datetime - @logObject.Message</span>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@if (LogBucket != null && LogBucket.Logs != null && !_showLogBackupFile)
{
    <div class="d-flex justify-content-between align-items-center pt-4">
        <h5 class="mb-0">
            <button class="btn btn-light" @onclick="DownloadFile" title="Download Log File" style="border: none; background: transparent;">
                <i class="bi bi-download"></i>
            </button> Logs
        </h5>
        <div class="d-flex align-items-center">
            <label class="me-2 mb-0" style="font-weight: normal;">Currently Logging:</label>
            <select class="form-select form-select-sm" style="width: auto;" @bind="SelectedLogLevel" @bind:after="OnLogLevelChanged">
                <option value="@LogType.Error">Error Only</option>
                <option value="@LogType.Warning">Warning + Error</option>
                <option value="@LogType.Info">Info + Warning + Error</option>
                <option value="@LogType.Debug">Debug + Info + Warning + Error</option>
                <option value="@LogType.Verbose">All (Verbose)</option>
            </select>
        </div>
    </div>


    <table class="table console-output mt-2">
        <thead>
            <tr>
                <th class="log-icon-header"></th>
                <th style="width: 150px;">Date Time (UTC)</th>
                <th>Message</th>
            </tr>
        </thead>
        <tbody>

            @foreach (var logObject in LogBucket.Logs.TakeLast(200).Reverse())  // Reverse the last 200 items
            {
                <tr class="@GetRowClass(logObject.Type.ToString(),logObject.Message)">
                    <td class="log-icon-cell">@GetLogIcon(logObject.Type)</td>
                    <td>@logObject.Datetime</td>
                    <td>@logObject.Message</td>
                </tr>
            }                

            @if (LogBucket.Logs.Count > 250)
            {
                <tr>
                    <td></td>
                    <td> ....</td>
                    <td> ..... </td>
                </tr>

                @foreach (var logObject in LogBucket.Logs.Take(30).Reverse()) // Reverse the top 30 items
                {
                    <tr class="@GetRowClass(logObject.Type.ToString(),logObject.Message)">
                        <td class="log-icon-cell">@GetLogIcon(logObject.Type)</td>
                        <td style="width: 120px;">@logObject.Datetime</td>
                        <td>@logObject.Message</td>
                    </tr>
                }
            }
        </tbody>
    </table>


}
else if (@_showLogBackupFile)
{
    <div class="alert alert-danger">
        <p>
            Failed to load the log file. It appears to be corrupt and has been backed up.
            Use the button below to download the previous log. A new log file will be created
            when the job is resumed.
        </p>
        <button class="btn btn-primary mx-2"
                @onclick="DownloadLogBackupFile"
                title="Download Log File">
            Download Backup File
        </button>
    </div>
}
@code {
    [Parameter]
    public string JobId { get; set; } = string.Empty;

    [Parameter]
    public MigrationJob? MigrationJob { get; set; }

    private LogBucket? LogBucket { get; set; }
    private List<LogObject> VerboseMessages { get; set; } = new();

    private string _errorMessage = string.Empty;
    private bool _migrationDetailsPopUpOpen;
    private Timer? _refreshTimer;
    private string _message = string.Empty;
    private bool _yesNoDialogOpen;
    private YesNoDialog.Category _yesNoDiaLogType= YesNoDialog.Category.CutoverNot;
    private bool _manageCollectionDialogOpen;
    private bool _resetChangeStreamDialogOpen;
    private bool _collectionDetailsDialogOpen;

    private bool _showLogBackupFile = false;
    private string _logBackupFile = string.Empty;
    private MigrationUnitBasic? _selectedMigrationUnit;

    // Loading spinner state for collection loading
    private bool _isLoadingCollections = false;

    // Log level filtering
    private LogType SelectedLogLevel
    {
        get => MigrationJob?.MinimumLogLevel ?? LogType.Info;
        set
        {
            if (MigrationJob != null)
            {
                MigrationJob.MinimumLogLevel = value;
            }
        }
    }

    // Pagination and filtering properties (kept for UI binding compatibility)
    private string _filterText = string.Empty;
    private int _currentPage = 1;
    private int _pageSize = 10;

    // Sorting properties
    private string _sortColumn = "DatabaseName";
    private bool _sortAscending = true;

    // Pagination helper
    private PaginationHelper<MigrationUnitBasic> _paginationHelper = new PaginationHelper<MigrationUnitBasic>(
        new List<MigrationUnitBasic>(),
        (mu, filterText) => true // Simple predicate, will be updated in UpdatePaginationHelper
    );

    // Cache to prevent re-sorting/filtering on every render
    private List<MigrationUnitBasic>? _cachedFilteredAndPagedUnits = null;
    private int _cachedFilteredItemsCount = 0;
    private string _cachedDisplayedItemsInfo = string.Empty;
    private int _cachedTotalPages = 0;
    private int _lastMigrationUnitsCount = 0;
    private string _lastSortColumn = string.Empty;
    private bool _lastSortAscending = true;
    private string _lastFilterText = string.Empty;
    private int _lastPageSize = 0;
    private int _lastCurrentPage = 0;

    private Func<MigrationUnitBasic, string, bool> GetFilterPredicate()
    {
        return (mu, filterText) =>
        {
            // Return true if any of the column values match the filter text
            if (string.IsNullOrWhiteSpace(filterText))
                return true;

            var searchText = filterText.ToLower();

            // Database Name
            if (mu.DatabaseName.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                return true;

            // Collection Name
            if (mu.CollectionName.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                return true;

            // Database.Collection combined
            if ($"{mu.DatabaseName}.{mu.CollectionName}".Contains(searchText, StringComparison.OrdinalIgnoreCase))
                return true;

            // Source Status / Download Status
            var sourceStatus = mu.SourceStatus == CollectionStatus.NotFound ? "Skipped (404)"
                                                : mu.SourceStatus == CollectionStatus.IsView ? "Skipped (VIEW)"
                                                : (mu.DumpComplete ? "Success" : $"{mu.DumpPercent:F1}%");
            if (sourceStatus.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                return true;

            // Upload/Restore Status (for DumpAndRestore jobs)
            if (MigrationJob?.JobType == OnlineMongoMigrationProcessor.Models.JobType.DumpAndRestore)
            {
                var uploadStatus = mu.SourceStatus == CollectionStatus.NotFound ? "Skipped (404)"
                                                    : mu.SourceStatus == CollectionStatus.IsView ? "Skipped (VIEW)"
                                                    : (mu.RestoreComplete || mu.RestorePercent == 100 ? "Success" : $"{mu.RestorePercent:F1}%");
                if (uploadStatus.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            // Change Stream Lag (Time Since Last Change/Sync Back)
            if (MigrationJob!=null & Helper.IsOnline(MigrationJob) == true)
            {
                var lagText = Helper.GetChangeStreamLag(mu, MigrationJob.ProcessingSyncBack);
                if (lagText.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            // Last Batch Changes Count
            if (Helper.IsOnline(MigrationJob) == true)
            {
                var batchCount = mu.CSUpdatesInLastBatch.ToString();
                if (batchCount.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            // Collection Status text variants
            if (mu.SourceStatus == CollectionStatus.NotFound && 
                ("missing".Contains(searchText) || "empty".Contains(searchText) || "notfound".Contains(searchText)))
                return true;

            if ((mu.DumpComplete && "success".Contains(searchText)) || 
                (mu.RestoreComplete && "success".Contains(searchText)))
                return true;

            // Percentage values
            if (searchText.Contains("%"))
            {
                var percentText = searchText.Replace("%", "").Trim();
                if (double.TryParse(percentText, out var searchPercent))
                {
                    if (Math.Abs(mu.DumpPercent - searchPercent) < 0.1)
                        return true;
                    if (Math.Abs(mu.RestorePercent - searchPercent) < 0.1)
                        return true;
                }
            }

            return false;
        };
    }

    #region Sorting Methods

    private async Task SortBy(string columnName)
    {
        if (_sortColumn == columnName)
        {
            _sortAscending = !_sortAscending;
        }
        else
        {
            _sortColumn = columnName;
            _sortAscending = true;
        }

        _currentPage = 1; // Reset to first page when sorting changes
        await InvokeAsync(StateHasChanged);
    }

    private string GetSortIcon(string columnName)
    {
        if (_sortColumn != columnName)
            return "bi-arrow-down-up"; // Neutral sort icon

        return _sortAscending ? "bi-arrow-up" : "bi-arrow-down";
    }

    private string GetSortClass(string columnName)
    {
        return _sortColumn == columnName ? "sorted-column" : "";
    }

    private List<MigrationUnitBasic> ApplySorting(List<MigrationUnitBasic> units)
    {
        if (units == null || !units.Any())
            return units ?? new List<MigrationUnitBasic>();

        return _sortColumn switch
        {
            "DatabaseName" => _sortAscending 
                ? units.OrderBy(u => u.DatabaseName).ToList()
                : units.OrderByDescending(u => u.DatabaseName).ToList(),

            "CollectionName" => _sortAscending
                ? units.OrderBy(u => u.CollectionName).ToList()
                : units.OrderByDescending(u => u.CollectionName).ToList(),

            "DownloadStatus" or "CopyStatus" => _sortAscending
                ? units.OrderBy(u => GetSortValueForStatus(u, false)).ToList()
                : units.OrderByDescending(u => GetSortValueForStatus(u, false)).ToList(),

            "UploadStatus" => _sortAscending
                ? units.OrderBy(u => GetSortValueForStatus(u, true)).ToList()
                : units.OrderByDescending(u => GetSortValueForStatus(u, true)).ToList(),

            "TimeSinceLastChange" => _sortAscending
                ? units.OrderBy(u => GetSortValueForTimestamp(u)).ToList()
                : units.OrderByDescending(u => GetSortValueForTimestamp(u)).ToList(),

            "LastBatchChanges" => _sortAscending
                ? units.OrderBy(u => u.CSUpdatesInLastBatch).ToList()
                : units.OrderByDescending(u => u.CSUpdatesInLastBatch).ToList(),

            _ => units
        };
    }

    private object GetSortValueForStatus(MigrationUnitBasic mu, bool isUploadStatus)
    {
        if (mu.SourceStatus == CollectionStatus.NotFound)
            return "0_Skipped (404)"; // Sort skipped items first

        if (mu.SourceStatus == CollectionStatus.IsView)
            return "0_Skipped (VIEW)"; // Sort skipped items first

        if (isUploadStatus)
        {
            if (mu.RestoreComplete || mu.RestorePercent == 100)
                return "2_Success"; // Sort completed items last
            return $"1_{mu.RestorePercent:000.0}%"; // Sort by percentage in middle
        }
        else
        {
            if (mu.DumpComplete)
                return "2_Success"; // Sort completed items last
            return $"1_{mu.DumpPercent:000.0}%"; // Sort by percentage in middle
        }
    }

    private DateTime GetSortValueForTimestamp(MigrationUnitBasic mu)
    {
        if (MigrationJob?.ProcessingSyncBack == true)
            return mu.SyncBackCursorUtcTimestamp;
        else
            return mu.CursorUtcTimestamp;
    }

    #endregion

    #region Pagination and Filtering Methods

    private void UpdatePaginationHelper()
    {
        // Check if we need to invalidate the cache
        var currentUnitsCount = @MigrationJob.MigrationUnitBasics?.Count ?? 0;
        bool needsUpdate = _cachedFilteredAndPagedUnits == null ||
                          currentUnitsCount != _lastMigrationUnitsCount ||
                          _sortColumn != _lastSortColumn ||
                          _sortAscending != _lastSortAscending ||
                          _filterText != _lastFilterText ||
                          _pageSize != _lastPageSize ||
                          _currentPage != _lastCurrentPage;

        if (!needsUpdate)
        {
            return; // Use cached data
        }

        var currentUnits = @MigrationJob.MigrationUnitBasics ?? new List<MigrationUnitBasic>();

        // Apply sorting before pagination
        currentUnits = ApplySorting(currentUnits);

        // Recreate the pagination helper only when needed
        _paginationHelper = new PaginationHelper<MigrationUnitBasic>(
            currentUnits,
            GetFilterPredicate()
        );

        // Update the helper with current component state
        _paginationHelper.FilterText = _filterText;
        _paginationHelper.PageSize = _pageSize;

        // Ensure current page is within valid bounds
        var totalPages = _paginationHelper.GetTotalPages();
        if (_currentPage > totalPages)
        {
            _currentPage = Math.Max(1, totalPages);
        }
        _paginationHelper.CurrentPage = _currentPage;

        // Cache the results to prevent redundant GetFilteredItems() calls
        _cachedFilteredAndPagedUnits = _paginationHelper.GetPagedItems();
        _cachedFilteredItemsCount = _paginationHelper.GetFilteredItemsCount();
        _cachedDisplayedItemsInfo = _paginationHelper.GetDisplayedItemsInfo();
        _cachedTotalPages = _paginationHelper.GetTotalPages();

        // Update tracking variables
        _lastMigrationUnitsCount = currentUnitsCount;
        _lastSortColumn = _sortColumn;
        _lastSortAscending = _sortAscending;
        _lastFilterText = _filterText;
        _lastPageSize = _pageSize;
        _lastCurrentPage = _currentPage;
    }

    private List<MigrationUnitBasic> GetFilteredAndPagedUnits()
    {
        UpdatePaginationHelper();
        return _cachedFilteredAndPagedUnits ?? new List<MigrationUnitBasic>();
    }

    private int GetTotalItemsCount()
    {
        return @MigrationJob.MigrationUnitBasics?.Count ?? 0;
    }

    private int GetFilteredItemsCount()
    {
        UpdatePaginationHelper();
        return _cachedFilteredItemsCount;
    }

    private string GetDisplayedItemsInfo()
    {
        UpdatePaginationHelper();
        return _cachedDisplayedItemsInfo;
    }

    private int GetTotalPages()
    {
        UpdatePaginationHelper();
        return _cachedTotalPages;
    }

    private bool IsFirstPage() 
    {
        UpdatePaginationHelper();
        return _paginationHelper.IsFirstPage();
    }

    private bool IsLastPage() 
    {
        UpdatePaginationHelper();
        return _paginationHelper.IsLastPage();
    }

    private int GetStartPage()
    {
        UpdatePaginationHelper();
        return _paginationHelper.GetStartPage();
    }

    private int GetEndPage()
    {
        UpdatePaginationHelper();
        return _paginationHelper.GetEndPage();
    }

    private async Task GoToPage(int pageNumber)
    {
        _currentPage = pageNumber;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnFilterChanged()
    {
        _currentPage = 1; // Reset to first page when filter changes
        await InvokeAsync(StateHasChanged);
    }

    private async Task ClearFilter()
    {
        _filterText = string.Empty;
        _currentPage = 1;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnPageSizeChanged()
    {
        _currentPage = 1; // Reset to first page when page size changes
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnLogLevelChanged()
    {
        // Save the job when log level changes
        var jobList = JobManager.GetJobList();
        MigrationJobContext.SaveMigrationJob(MigrationJob);

        await InvokeAsync(StateHasChanged);
    }
    #endregion

    private string GetRowClass(string type, string message)
    {
        // Return CSS class based on LogType
        // Treat deprecated "Message" as "Info"
        return type switch
        {
            "Error" => "error-row",
            "Warning" => "warning-row",
            "Message" => "info-row",  // Deprecated, treat as Info
            "Info" => "info-row",
            "Debug" => "debug-row",
            "Verbose" => "verbose-row",
            _ => string.Empty
        };
    }

    private MarkupString GetLogIcon(LogType logType)
    {
        // Return Bootstrap icon based on LogType
        #pragma warning disable CS0618 // Type or member is obsolete
        return logType switch
        {
            LogType.Error => new MarkupString("<i class='bi bi-x-circle-fill'></i>"),
            LogType.Warning => new MarkupString("<i class='bi bi-exclamation-triangle-fill'></i>"),
            LogType.Message => new MarkupString("<i class='bi bi-info-circle-fill'></i>"),  // Deprecated, treat as Info
            LogType.Info => new MarkupString("<i class='bi bi-info-circle-fill'></i>"),
            LogType.Debug => new MarkupString("<i class='bi bi-bug-fill'></i>"),
            LogType.Verbose => new MarkupString("<i class='bi bi-chat-dots-fill'></i>"),
            _ => new MarkupString("")
        };
        #pragma warning restore CS0618
    }

    private void GoBack()
    {
        _refreshTimer?.Dispose();
        NavigationManager.NavigateTo("/"); // Navigate back to the previous page
    }

    private async Task ToggleAutoRefresh()
    {
        await InvokeAsync(() =>
        {
            if (MigrationJob == null) return;

            MigrationJob.AutoRefreshEnabled = !MigrationJob.AutoRefreshEnabled;

            if (MigrationJob.AutoRefreshEnabled)
            {
                // Re-enable: Start the timer and do an immediate refresh
                if (_refreshTimer == null)
                {
                    _refreshTimer = new Timer(Refresh, null, 0, 5000); // Update every 5 seconds
                }

                // Trigger immediate refresh
                MigrationJob = JobManager.GetMigrationJobById(JobId);// GetMigrations()(m => m.Id == JobId);
                if (MigrationJob != null && (MigrationJob.IsStarted || JobManager.DidMigrationJobExitRecently(JobId)) && !_showLogBackupFile)
                {
                    if (_isLoadingCollections && @MigrationJob.MigrationUnitBasics != null && @MigrationJob.MigrationUnitBasics.Count > 0)
                    {
                        _isLoadingCollections = false;
                    }

                    LogBucket = JobManager.GetLogBucket(JobId, out string logBackup, out bool isLive);
                    if (!string.IsNullOrEmpty(logBackup) && logBackup != JobId)
                        _logBackupFile = logBackup;

                    VerboseMessages = JobManager.GetMonitorMessages(JobId ?? string.Empty);
                }
            }
            else
            {
                // Disable: Stop and dispose the timer
                _refreshTimer?.Dispose();
                _refreshTimer = null;
            }

            StateHasChanged();
        });
    }

    private void StartAutoRefresh()
    {
        _showLogBackupFile = false;
        _logBackupFile = string.Empty;  
        MigrationJob = JobManager.GetMigrationJobById(JobId);// GetMigrations()(m => m.Id == JobId);
        if (MigrationJob != null && MigrationJob.IsStarted)
        {
            // Only start timer if AutoRefreshEnabled is true (default)
            if (MigrationJob.AutoRefreshEnabled)
            {
                _refreshTimer = new Timer(Refresh, null, 0, 5000); // Update every 5 seconds
            }
            ScheduleUpdateTimerStatus(JobId, 30); // check to set the timer status based on whether the job is live or not
        }

    }

    private void ShowCollectionDetails(MigrationUnitBasic mu)
    {
        _selectedMigrationUnit = mu;
        _collectionDetailsDialogOpen = true;
    }

    private List<MigrationJob> GetMigrations()
    {
        var ids = JobManager.GetMigrationIds(out string errorMessage);
        var list = JobManager.GetMigrationJobs(ids);
        //var list = JobManager.GetMigrations(out string errorMessage);
        if (!string.IsNullOrEmpty(errorMessage))
        {
            _errorMessage = errorMessage;
        }
        // Return a snapshot copy to prevent cross-thread access issues
        // The original list can be modified by background threads (migration workers, timers)
        // while the UI thread iterates over it, causing casting/enumeration exceptions
        return list != null ? new List<MigrationJob>(list) : new List<MigrationJob>();
    }

    private async Task DownloadLogBackupFile()
    {
        if (string.IsNullOrEmpty(_logBackupFile))
        {
            return;
        }
        await Downloader(_logBackupFile, $"Backup_{_logBackupFile}");
    }


    private async Task DownloadFile()
    {
        if (string.IsNullOrEmpty(JobId))
        {
            return;
        }
        await Downloader(JobId, JobId);
    }

    private async Task Downloader(string fileName, string displayName)
    {

        var url = $"/api/File/download/log/{fileName}";

        var request = new HttpRequestMessage(HttpMethod.Get, url);      

        var response = await HttpClient.GetAsync(url);

        if (response.IsSuccessStatusCode)
        {
            var fileBytes = await response.Content.ReadAsByteArrayAsync();
            var contentType = response.Content.Headers.ContentType?.ToString() ?? "application/octet-stream";

            // Use JavaScript to trigger the file download
            await JS.InvokeVoidAsync("downloadFile", fileBytes, $"{displayName}.json", contentType);
        }
        else
        {
            await JS.InvokeVoidAsync("open", url, "_blank"); // browser navigates directly
        }
    }


    private void Refresh(object? state)
    {
        // Marshal ALL component state changes to the UI thread to prevent cross-thread access issues
        InvokeAsync(() =>
        {
            MigrationJob = JobManager.GetMigrationJobById(JobId);// GetMigrations()(m => m.Id == JobId);
            if (MigrationJob != null && (MigrationJob.IsStarted || JobManager.DidMigrationJobExitRecently(JobId)) && !_showLogBackupFile)
            {
                // Check if we should hide loading spinner
                if (_isLoadingCollections && @MigrationJob.MigrationUnitBasics != null && @MigrationJob.MigrationUnitBasics.Count > 0)
                {
                    _isLoadingCollections = false;
                }

                LogBucket = JobManager.GetLogBucket(JobId, out string logBackup, out bool isLive);
                if (!string.IsNullOrEmpty(logBackup) && logBackup != JobId)
                    _logBackupFile = logBackup;

                VerboseMessages = JobManager.GetMonitorMessages(JobId ?? string.Empty);
                //Console.WriteLine($"Refresh called for {JobId}");

                if (!string.IsNullOrEmpty(_logBackupFile))
                {
                    _refreshTimer?.Dispose();
                    _refreshTimer = null;
                    _showLogBackupFile = true;
                }
                else
                    _showLogBackupFile = false;

                // Invalidate all pagination caches when data refreshes
                _cachedFilteredAndPagedUnits = null;
                _cachedFilteredItemsCount = 0;
                _cachedDisplayedItemsInfo = string.Empty;
                _cachedTotalPages = 0;

                StateHasChanged();
            }
            else
            {    
                _refreshTimer?.Dispose();
            }
        });
    }

    private async Task UpdateTimerStatus(string id, int seconds)
    {
        await Task.Delay(TimeSpan.FromSeconds(seconds)); // Wait for the specified seconds before processing

        Console.WriteLine($"UpdateTimerStatus Invoked");

        if (id!= JobId)
        {
            return; // Exit if the JobId does not match
        }

        MigrationJob = JobManager.GetMigrationJobById(JobId);//GetMigrations()(m => m.Id == id);
        if (MigrationJob != null && MigrationJob.IsStarted)
        {
            LogBucket = JobManager.GetLogBucket(id, out string logBackup, out bool isLive);
            if (!string.IsNullOrEmpty(logBackup) && logBackup != JobId)
                _logBackupFile = logBackup;

            if (!isLive)               
            {
                _refreshTimer?.Dispose(); // Stop the timer if not live
                _refreshTimer = null;
                //_showLogBackupFile = false;
            }
        }

    }

    private void ScheduleUpdateTimerStatus(string id, int seconds)
    {
        _ = Task.Run(async () => await UpdateTimerStatus(id, seconds));
    }

    private Task<bool> CheckIfNameExistsAsync(string name)
    {
        //always false as we are not checking for duplicate names in this case
        return Task.FromResult(false);
    }

    // private string GetChangeStreamLag(MigrationUnit mu, bool isSyncBack=false)
    // {
    //     DateTime timestamp;
    //     if (isSyncBack)
    //     {
    //         timestamp = mu.SyncBackCursorUtcTimestamp;
    //     }
    //     else
    //     {
    //         timestamp = mu.CursorUtcTimestamp;
    //     }

    //     if (timestamp == DateTime.MinValue || mu.ResetChangeStream)
    //     {
    //         return "NA";
    //     }

    //     var currentUtc = DateTime.UtcNow;
    //     var lag = currentUtc - timestamp;

    //     if (lag.TotalSeconds < 0)
    //     {
    //         return "Invalid";
    //     }

    //     return $"{(int)lag.TotalMinutes} min {(int)lag.Seconds} sec";
    // }

    private bool CheckCutoverReadiness()
    {
        //var mjCheck = MigrationJob;
        //if (mjCheck?.MigrationUnitIds == null) return false;
        foreach (var mu in MigrationJob.MigrationUnitBasics)
        {
            if (mu.SourceStatus != CollectionStatus.NotFound)
            {
                if (mu.DumpPercent != 100 || mu.RestorePercent != 100)
                    return false;
            }
        }
        return true;
    }

    protected override async Task OnParametersSetAsync()
    {
        MigrationJob = JobManager.GetMigrationJobById(JobId);

        if (MigrationJob == null) // Fixed the condition to check for null
        {
            return;
        }


        LogBucket = JobManager.GetLogBucket(JobId, out string logBackup, out bool isLive);
        if (!string.IsNullOrEmpty(logBackup) && logBackup != JobId)
            _logBackupFile = logBackup;

        if (!string.IsNullOrEmpty(_logBackupFile))
        {
            _showLogBackupFile = true;
        }
        else
        {
            _showLogBackupFile = false;
            if (IsResumeEnabled())
            {
                await ResumeJob();
            }
            var mjLocal = MigrationJob;
            if (mjLocal != null && !mjLocal.IsCancelled && !mjLocal.IsCompleted && IsJobRunning())// && MigrationJob.CurrentlyActive
            {
                StartAutoRefresh();
            }
        }        
    }

    private async Task<bool> OnMigrationDetailsPopUpSubmit(MigrationJob? job, string sourceConnectionString, string targetConnectionString)
    {
        _migrationDetailsPopUpOpen = false;
        await Task.Delay(100);
        var mj = MigrationJob;
        if (job == null || mj == null)
        {
            return false;
        }

        if (!string.IsNullOrEmpty(sourceConnectionString))
            MigrationJobContext.SourceConnectionString[mj.Id] = sourceConnectionString;

        if (!string.IsNullOrEmpty(targetConnectionString))
            MigrationJobContext.TargetConnectionString[mj.Id] = targetConnectionString;

        // Copy connection strings from the provided job into the current migration
        // mj.SourceConnectionString = job.SourceConnectionString;
        // mj.TargetConnectionString = job.TargetConnectionString;

        // MigrationJob.CurrentlyActive = true;
        mj.IsCancelled = false;

        if (!mj.StartedOn.HasValue)
            mj.StartedOn = DateTime.UtcNow;

        mj.IsStarted = true;  

        var jobList = JobManager.GetJobList();
        MigrationJobContext.SaveMigrationJob(mj);
        MigrationJobContext.SaveJobList(jobList);


        // Check if we should show the loading spinner
        if (mj.MigrationUnitBasics == null || mj.MigrationUnitBasics.Count == 0)
        {
            _isLoadingCollections = true;
            await InvokeAsync(StateHasChanged);
        }

        // Run the long task on a separate thread
        await Task.Run(() =>
        {
            // JobManager.DisposeLogs();

            if (mj!.ProcessingSyncBack && !mj.IsSimulatedRun)
            {
                JobManager.SyncBackToSource(MigrationJobContext.SourceConnectionString[mj.Id] ?? string.Empty,
                MigrationJobContext.TargetConnectionString[mj.Id] ?? string.Empty,
                mj);
            }
            else
            {
                JobManager.StartMigrationAsync(mj,
                MigrationJobContext.SourceConnectionString[mj.Id] ?? string.Empty,
                MigrationJobContext.TargetConnectionString[mj.Id] ?? string.Empty,
                mj.NameSpaces ?? string.Empty,
                mj.JobType,
                Helper.IsOnline(mj));
            }
        });

        StartAutoRefresh();
        return true;
    }

    private void RunComparison()
    {
        _errorMessage = string.Empty;

        // Check if SourceConnectionString is blank
        if (string.IsNullOrWhiteSpace(MigrationJobContext.SourceConnectionString[MigrationJob.Id]))
        {
            _errorMessage = "Source connection string is not available. Please use 'Resume Job' → 'With Updated Connection Strings' to provide connection details, then pause the job before running comparison.";
            return;
        }

        if (IsResumeEnabled())
        {
            _yesNoDiaLogType=YesNoDialog.Category.RunComparisonNot;
            _message = "Comparing collections using random sampling may take some time. This process will block the migration and could cause delays. Please confirm if you want to continue with the comparison. You will need to resume the job to continue.";
            _yesNoDialogOpen = true;

        }
        else
        {
            _errorMessage = "Please pause the job before you run the comparison.";
        }
    }

    private void ResetChangeStream()
    {
        _errorMessage = string.Empty;

        if (IsResumeEnabled() && !(MigrationJob?.ProcessingSyncBack ?? false))
        {
            _resetChangeStreamDialogOpen = true;
        }
        else
        {
            if (MigrationJob?.ProcessingSyncBack ?? false)
                _errorMessage = "You cannot reset change stream after sync back has started.";
            else
                _errorMessage = "Please pause the job before resetting change stream.";
        }
    }
    private void ManageCollections()
    {
        _errorMessage = string.Empty;

        // Check if SourceConnectionString is blank
        if (string.IsNullOrWhiteSpace(MigrationJobContext.SourceConnectionString[MigrationJob.Id]))
        {
            _errorMessage = "Source connection string is not available. Please use 'Resume Job' → 'With Updated Connection Strings' to provide connection details, then pause the job before updating collections.";
            return;
        }

        if (IsResumeEnabled() && !(MigrationJob?.ProcessingSyncBack ?? false))
        {
            _manageCollectionDialogOpen = true;
        }
        else
        {
            if (MigrationJob?.ProcessingSyncBack ?? false)
                _errorMessage = "You cannot update collections after sync back has started.";
            else
                _errorMessage = "Please pause the job before updating collections.";
        }
    }
    private async Task ResumeJobWithNewConnectionString()
    {
        await DecideAndResumeJob(true);
    }

    private async Task ResumeJobWithExistingConnectionString()
    {
        if (IsResumeEnabled() && NoOtherActiveJobs())
        {
            var mjResume = MigrationJob;
            if (mjResume != null)
                await OnMigrationDetailsPopUpSubmit(mjResume, string.Empty, string.Empty);
            else
                _migrationDetailsPopUpOpen = true;
        }
        else
            _migrationDetailsPopUpOpen = true;
    }

    private async Task ResumeJob()
    {
        await DecideAndResumeJob(false);
    }

    private async Task DecideAndResumeJob(bool showDialog=false)
    {
        _errorMessage = string.Empty;
        if (IsResumeEnabled() && NoOtherActiveJobs())
        {
            if(showDialog)
                _migrationDetailsPopUpOpen = true;
            else
            {
                if (CanAutoStart())
                {
                    var mjAuto = MigrationJob;
                    if (mjAuto != null)
                        await OnMigrationDetailsPopUpSubmit(mjAuto, string.Empty, string.Empty);
                }

            }
        }
        else
        {
            _errorMessage = "Please stop active job, before starting/resuming a job.";
        }
    }

    private bool IsJobRunning()
    {
        return JobManager.IsProcessRunning(JobId);
    }

    private void InitSyncBackJob()
    {
        _message = "You are about to initiate cutover and begin syncing data back to the source. Proceed only if all changes from the source have already been replicated to the target. This action is irreversible. Are you sure you want to cutover?";
        _yesNoDiaLogType = YesNoDialog.Category.SyncBackNot;
        _yesNoDialogOpen = true;      
    }

    private void CompleteJob()
    {
        if (MigrationJob?.ProcessingSyncBack ?? false)
        {
            _message = "You can't resume a job after its completed. Are you sure you want to complete the job?";
            _yesNoDiaLogType = YesNoDialog.Category.CompleteNot;
        }
        else
        {
            _message = "You can't resume a job after its cutover. Are you sure you want to cutover?";
            _yesNoDiaLogType = YesNoDialog.Category.CutoverNot;
        }
        _yesNoDialogOpen = true;
    }


    private void HandleCollectionDetailsClose()
    {
        _collectionDetailsDialogOpen = false;
        _selectedMigrationUnit = null;     
    }

    private void OnCSReset(List<MigrationUnit> migrationUnits)
    {
        _resetChangeStreamDialogOpen = false;
        var mj = MigrationJob;
        if (migrationUnits != null && mj?.MigrationUnitBasics != null)
        {
            var jobList = JobManager.GetJobList();
            var migrationUnitsToReset = JobManager.GetMigrationUnits(mj);
            for (int i = 0; i < migrationUnitsToReset.Count; i++)
            {
                if (migrationUnits.Contains(migrationUnitsToReset[i]))
                    migrationUnitsToReset[i].ResetChangeStream = true; // Reset change stream for every second collection
                else
                    migrationUnitsToReset[i].ResetChangeStream = false; // Ensure other collections are not reset

                migrationUnitsToReset[i].ParentJob = MigrationJob;
                migrationUnitsToReset[i].UpdateParentJob();

                MigrationJobContext.SaveMigrationUnit(migrationUnitsToReset[i],false);
            }

            if (MigrationJobContext.SaveMigrationJob(MigrationJob))
                return;
        }
    }


    private async void OnCollectionsUpdated(List<MigrationUnit> migrationUnits)
    {
        _manageCollectionDialogOpen = false;
        //var mj = MigrationJob;
        
        //var jobList = JobManager.GetJobList();

        //var mj2 = MigrationJob;
        if (migrationUnits != null && MigrationJob != null)
        {
            // Get IDs for comparison
            var existingIds = MigrationJob.MigrationUnitBasics.Select(mu => mu.Id).ToHashSet();
            var newIds = migrationUnits.Select(mu => mu.Id).ToHashSet();

            //get ids that are no llonger present in newUnits
            var delList = MigrationJob.MigrationUnitBasics.FindAll(mu => !newIds.Contains(mu.Id));

            foreach (var tobDel in delList)
            {
                tobDel.ParentJob = MigrationJob;
                tobDel.Remove();
            }


            // Add new units that don’t exist in existingUnits
            foreach (var mu in migrationUnits)
            {
                if (!MigrationJob.MigrationUnitBasics.Any(x => x.DatabaseName == mu.DatabaseName && x.CollectionName == mu.CollectionName))
                {
                    MigrationJobContext.SaveMigrationUnit(mu,false);
                    MigrationJob.MigrationUnitBasics.Add(mu.GetBasic());
                }
            }

            MigrationJob.NameSpaces = string.Join(",", migrationUnits.Select(x => x.DatabaseName + "." + x.CollectionName));

            MigrationJobContext.SaveMigrationJob(MigrationJob);

            Refresh(null);
        }
    }

    


    private void YesNoDialogSubmit(YesNoDialog.YesNoDialogResult result)
    {
        _yesNoDialogOpen = false;
        var jobList = JobManager.GetJobList();
        if (result.IsConfirmed)
        {           

            if (result.DiaLogType == YesNoDialog.Category.CutoverNot || result.DiaLogType == YesNoDialog.Category.CompleteNot)
            {
                JobManager.StopMigration();
                var mjc = MigrationJob;
                if (mjc != null)
                {
                    mjc.IsCancelled = true;
                    mjc.IsCompleted = true;
                }

                if (MigrationJobContext.SaveMigrationJob(mjc))
                    return;

                _refreshTimer = null;
            }
            else if (result.DiaLogType == YesNoDialog.Category.SyncBackNot)
            {
                var mjs = MigrationJob;
                if (mjs != null)
                {
                    JobManager.SyncBackToSource(MigrationJobContext.SourceConnectionString[mjs.Id] ?? string.Empty,
                                                MigrationJobContext.TargetConnectionString[mjs.Id] ?? string.Empty,
                                                mjs);
                }
                if (MigrationJobContext.SaveMigrationJob(mjs))
                    return;
            }
            else if( result.DiaLogType == YesNoDialog.Category.RunComparisonNot)
            {
                var mjr = MigrationJob;
                if (mjr != null)
                {
                    mjr.RunComparison = true;
                }
                if (MigrationJobContext.SaveMigrationJob(mjr))
                    return;
            }

        }
        else
        {
            if (result.DiaLogType == YesNoDialog.Category.RunComparisonNot)
            {
                var mjr2 = MigrationJob;
                if (mjr2 != null)
                {
                    mjr2.RunComparison = false;
                }
                if (MigrationJobContext.SaveMigrationJob(mjr2))
                    return;
            }
        }
    }

    private void PauseJobImmediate()
    {
        _errorMessage = string.Empty;
        JobManager.StopMigration();
        var jobList = JobManager.GetJobList();
        if (MigrationJobContext.SaveMigrationJob(MigrationJob))
            return;
        _refreshTimer = null;
    }

    private void PauseJobControlled()
    {
        _errorMessage = string.Empty;
        JobManager.ControlledPauseMigration();

        var jobList = JobManager.GetJobList();
        if (MigrationJobContext.SaveMigrationJob(MigrationJob))
            return;
    }

    private async Task IncreaseDumpWorkers()
    {
        if (MigrationJob != null && MigrationJob.CurrentDumpWorkers < 16)
        {
            int newCount = MigrationJob.CurrentDumpWorkers + 1;
            JobManager.AdjustDumpWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task DecreaseDumpWorkers()
    {
        if (MigrationJob != null && MigrationJob.CurrentDumpWorkers > 1)
        {
            int newCount = MigrationJob.CurrentDumpWorkers - 1;
            JobManager.AdjustDumpWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task IncreaseRestoreWorkers()
    {
        if (MigrationJob != null && MigrationJob.CurrentRestoreWorkers < 16)
        {
            int newCount = MigrationJob.CurrentRestoreWorkers + 1;
            JobManager.AdjustRestoreWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task DecreaseRestoreWorkers()
    {
        if (MigrationJob != null && MigrationJob.CurrentRestoreWorkers > 1)
        {
            int newCount = MigrationJob.CurrentRestoreWorkers - 1;
            JobManager.AdjustRestoreWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task IncreaseInsertionWorkers()
    {
        if (MigrationJob != null && MigrationJob.CurrentInsertionWorkers < 16)
        {
            int newCount = MigrationJob.CurrentInsertionWorkers + 1;
            JobManager.AdjustInsertionWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task DecreaseInsertionWorkers()
    {
        if (MigrationJob != null && MigrationJob.CurrentInsertionWorkers > 1)
        {
            int newCount = MigrationJob.CurrentInsertionWorkers - 1;
            JobManager.AdjustInsertionWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private bool NoOtherActiveJobs()
    {        

        string activeJob = JobManager?.GetRunningJobId() ?? string.Empty;
        if (activeJob != string.Empty && activeJob != JobId)
            return false;
        else
            return true;
    }

    private  bool  IsPauseEnabled()
    {
        var mj = MigrationJob;
        return mj != null && !mj.IsCancelled && !mj.IsCompleted && IsJobRunning() && NoOtherActiveJobs();
    }


    private bool IsResumeEnabled()
    {
        var mj = MigrationJob;
        return mj != null && !mj.IsCompleted && !IsJobRunning();
    }

    private bool CanAutoStart()
    {
        var mj = MigrationJob;
        if (IsResumeEnabled() && NoOtherActiveJobs() && mj != null && mj.IsStarted &&
            (!string.IsNullOrEmpty(MigrationJobContext.SourceConnectionString[mj.Id]) || !string.IsNullOrEmpty(MigrationJobContext.TargetConnectionString[mj.Id])))
        {
            return true;
        }
        return false;
    }

    public void Dispose()
    {
        _refreshTimer?.Dispose();
        _refreshTimer = null;
    }
}

