@page "/migrationjobviewer/{jobId}"
@using MigrationJobType = OnlineMongoMigrationProcessor.MigrationJob
@using MongoMigrationWebApp.Components
@using MongoMigrationWebApp.Helpers
@using OnlineMongoMigrationProcessor
@using OnlineMongoMigrationProcessor.Context
@using OnlineMongoMigrationProcessor.Helpers

@inject Service.JobManager JobManager
@inject NavigationManager NavigationManager
@inject IJSRuntime JS
@inject Service.FileService FileService
@inject HttpClient HttpClient
@implements IDisposable

<div class="d-flex justify-content-between align-items-center mb-3">
    <h3>
        <button class="btn btn-light" @onclick="GoBack" title="Back to Job List" style="border: none; background: transparent;">
            <i class="bi bi-arrow-left"></i>
        </button>
        @CurrentlyLoadedMigrationJob?.Name - Job Status
    </h3>
    <div class="d-flex align-items-center mb-3">

        @if (IsResumeEnabled() && !_isLoadingCollections)
        {
            <div class="btn-group mx-2">
                <button class="btn btn-primary dropdown-toggle" type="button" id="resumeJobDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Resume Job
                </button>
                <ul class="dropdown-menu" aria-labelledby="resumeJobDropdown">
                    <li><a class="dropdown-item" @onclick="ResumeJobWithNewConnectionString">With Updated Connection Strings</a></li>
                    @if (CurrentlyLoadedMigrationJob != null && !string.IsNullOrEmpty(MigrationJobContext.SourceConnectionString[CurrentlyLoadedMigrationJob.Id]) && !string.IsNullOrEmpty(MigrationJobContext.TargetConnectionString[CurrentlyLoadedMigrationJob.Id]))
                    {
                        <li><a class="dropdown-item" @onclick="ResumeJobWithExistingConnectionString">With Existing Connection Strings</a></li>
                    }
                </ul>
            </div>
        }

        @if (IsPauseEnabled() && !_isLoadingCollections)
        {
            @* Pause Job - with dropdown for controlled pause if applicable *@
            @if (CurrentlyLoadedMigrationJob != null && JobManager.IsControlledPauseApplicable(CurrentlyLoadedMigrationJob.JobType, CurrentlyLoadedMigrationJob))
            {
                <div class="btn-group mx-2">
                    <button class="btn btn-primary dropdown-toggle" type="button" id="pauseJobDropdown" data-bs-toggle="dropdown" aria-expanded="false" title="Choose pause method">
                        Pause Job
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="pauseJobDropdown">
                        <li><a class="dropdown-item" @onclick="PauseJobControlled" title="Stops accepting new chunks but allows active chunks to complete"><i class="bi bi-pause-circle"></i> Controlled Pause (Graceful)</a></li>
                        <li><a class="dropdown-item" @onclick="PauseJobImmediate" title="Immediately cancels all operations"><i class="bi bi-stop-circle"></i> Immediate Stop</a></li>
                    </ul>
                </div>
            }
            else
            {
                <button class="btn btn-primary mx-2" title="Pause Job" @onclick="PauseJobImmediate">Pause Job</button>
            }
            
            @* Display controlled pause status *@
            @if (JobManager.IsControlledPauseRequested() && IsJobRunning())
            {
                <span class="badge bg-warning text-dark mx-2" title="Controlled pause in progress - waiting for active chunks to complete">
                    <i class="bi bi-hourglass-split"></i> Pausing...
                </span>
            }
            
            @* Worker adjustment dropdown - only for DumpAndRestore jobs with parallel processing enabled *@
            @if (CurrentlyLoadedMigrationJob?.JobType == OnlineMongoMigrationProcessor.Models.JobType.DumpAndRestore &&
                    CurrentlyLoadedMigrationJob?.EnableParallelProcessing == true && !CheckCutoverReadiness())
            {
                <div class="btn-group mx-2">
                    <button class="btn btn-outline-secondary dropdown-toggle" type="button" id="workerAdjustmentDropdown" data-bs-toggle="dropdown" aria-expanded="false" title="Adjust parallel processing workers. D=Dump processes, R=Restore processes, I=Insertion workers per restore process">
                        <i class="bi bi-speedometer2"></i> D:@(CurrentlyLoadedMigrationJob?.CurrentDumpWorkers ?? 0), R:@(CurrentlyLoadedMigrationJob?.CurrentRestoreWorkers ?? 0), I:@(CurrentlyLoadedMigrationJob?.CurrentInsertionWorkers ?? 0)
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="workerAdjustmentDropdown">
                        <li><a class="dropdown-item" @onclick="IncreaseDumpWorkers" title="Increase the number of parallel mongodump processes to speed up data extraction from source"><i class="bi bi-plus-circle"></i> Dump Instances</a></li>
                        <li><a class="dropdown-item" @onclick="DecreaseDumpWorkers" title="Decrease the number of parallel mongodump processes to reduce load on source"><i class="bi bi-dash-circle"></i> Dump Instances</a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" @onclick="IncreaseRestoreWorkers" title="Increase the number of parallel mongorestore processes to speed up data insertion to target"><i class="bi bi-plus-circle"></i> Restore Instances</a></li>
                        <li><a class="dropdown-item" @onclick="DecreaseRestoreWorkers" title="Decrease the number of parallel mongorestore processes to reduce load on target"><i class="bi bi-dash-circle"></i> Restore Instances</a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" @onclick="IncreaseInsertionWorkers" title="Increase the number of insertion threads per mongorestore process for faster document insertion"><i class="bi bi-plus-circle"></i> Insertion Workers</a></li>
                        <li><a class="dropdown-item" @onclick="DecreaseInsertionWorkers" title="Decrease the number of insertion threads per mongorestore process to reduce target database load"><i class="bi bi-dash-circle"></i> Insertion Workers</a></li>
                    </ul>
                </div>
            }
            @if (CurrentlyLoadedMigrationJob != null && Helper.IsOnline(CurrentlyLoadedMigrationJob) && CurrentlyLoadedMigrationJob.SyncBackEnabled && !CurrentlyLoadedMigrationJob.ProcessingSyncBack)
            {
                <button class="btn btn-warning dropdown-toggle" title="Perform Cut Over" disabled="@(!CheckCutoverReadiness())" data-bs-toggle="dropdown" aria-expanded="false">Cut Over</button>

                <ul class="dropdown-menu" aria-labelledby="performCutOverDropdown">
                    <li><a class="dropdown-item" @onclick="InitSyncBackJob">With Sync Back</a></li>
                    <li><a class="dropdown-item" @onclick="CompleteJob">Without Sync Back</a></li>

                </ul>
            }
            else if (CurrentlyLoadedMigrationJob != null && Helper.IsOnline(CurrentlyLoadedMigrationJob) && CurrentlyLoadedMigrationJob.SyncBackEnabled && CurrentlyLoadedMigrationJob.ProcessingSyncBack)
            {
                <button class="btn btn-warning" title="Complete Job" @onclick="CompleteJob">Complete Job</button>
            }
            else if (CurrentlyLoadedMigrationJob != null && Helper.IsOnline(CurrentlyLoadedMigrationJob) && !CurrentlyLoadedMigrationJob.SyncBackEnabled)
            {
                <button class="btn btn-warning" title="Perform Cut Over" disabled="@(!CheckCutoverReadiness())" @onclick="CompleteJob">Cut Over</button>
            }

            <button class="btn btn-toolbar" title="Refresh" @onclick="Refresh">
                <i class="bi bi-arrow-repeat"></i>
            </button>

            <button class="btn btn-sm @((CurrentlyLoadedMigrationJob?.AutoRefreshEnabled ?? true) ? "btn-outline-success" : "btn-outline-secondary") ms-2" 
                    @onclick="ToggleAutoRefresh" 
                    title="@((CurrentlyLoadedMigrationJob?.AutoRefreshEnabled ?? true) ? "Auto-refresh is ON - Click to pause UI updates" : "Auto-refresh is OFF - Click to resume UI updates")"
                    style="border: 1px solid;">
                <i class="bi @((CurrentlyLoadedMigrationJob?.AutoRefreshEnabled ?? true) ? "bi-play-fill" : "bi-pause-fill")"></i>
            </button>
        }

    </div>
</div>


@if (!string.IsNullOrEmpty(_errorMessage))
{
    <div class="alert alert-danger mt-2">
        @_errorMessage
        <button type="button" class="btn-close btn-close-sm" aria-label="Close" @onclick="() => _errorMessage = string.Empty"></button>
    </div>
}


@if (_migrationDetailsPopUpOpen && CurrentlyLoadedMigrationJob != null)
{
    <MongoMigrationWebApp.Components.MigrationDetails NewMode=false
                                                      Job="@CurrentlyLoadedMigrationJob"
                                                      OnSubmit="@OnMigrationDetailsPopUpSubmit"
                                                      CheckNameExists="CheckIfNameExistsAsync" />
}

@if (_yesNoDialogOpen)
{
   <YesNoDialog Type=_yesNoDiaLogType Caption="Confirmation Required" Message="@_message" OnClose="@YesNoDialogSubmit" />
}
@if (_manageCollectionDialogOpen && CurrentlyLoadedMigrationJob != null)
{
    <ManageCollections MigrationJob="@CurrentlyLoadedMigrationJob" MigrationUnits="@JobManager.GetMigrationUnits(CurrentlyLoadedMigrationJob)" SourceConnectionString="@MigrationJobContext.SourceConnectionString[CurrentlyLoadedMigrationJob.Id]" OnCollectionsUpdated="@OnCollectionsUpdated" />
}

@if (_resetChangeStreamDialogOpen && CurrentlyLoadedMigrationJob != null)
{
    <ResetChangeStream MigrationUnits="@((@JobManager.GetMigrationUnits(CurrentlyLoadedMigrationJob) ?? new List<MigrationUnit>()).Where(mu => Helper.IsMigrationUnitValid(mu)).ToList())" OnCollectionsUpdated="@OnCSReset" />
}
@if (_collectionDetailsDialogOpen && _selectedMigrationUnit != null)
{
    <CollectionDetails MigrationJob="@CurrentlyLoadedMigrationJob" MigrationUnit="@MigrationJobContext.GetMigrationUnit(_selectedMigrationUnit.Id, CurrentlyLoadedMigrationJob.Id)" OnClose="HandleCollectionDetailsClose" />
}

@* Collections Loading Spinner *@
@if (_isLoadingCollections)
{
    <div class="d-flex justify-content-center align-items-center my-4">
        <div class="text-center">
            <div class="spinner-border text-primary mb-3" role="status" aria-hidden="true" style="width: 3rem; height: 3rem;">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div>
                <h5>Loading Collections...</h5>
                <p class="text-muted">Please wait while we discover and load the collections from your database.</p>
            </div>
        </div>
    </div>
}

@* Collections Filter and Pagination Controls *@
@if (CurrentlyLoadedMigrationJob.MigrationUnitBasics != null && CurrentlyLoadedMigrationJob.MigrationUnitBasics.Count > 0 && !_isLoadingCollections)
{
    <div class="collections-filter-section">
        <div class="row">
            <div class="col-md-8">
                <div class="input-group filter-input-group">
                    <span class="input-group-text"><i class="bi bi-search"></i></span>
                    <input type="text" class="form-control" placeholder="Filter collections by any column (database, collection, status, etc.)" 
                           @bind="_filterText" @bind:event="oninput" @onkeyup="OnFilterChanged" />
                    @if (!string.IsNullOrWhiteSpace(_filterText))
                    {
                        <button class="btn btn-outline-secondary filter-clear-btn" type="button" @onclick="ClearFilter" title="Clear filter">
                            <i class="bi bi-x"></i>
                        </button>
                    }
                </div>
            </div>
            <div class="col-md-4">
                <div class="d-flex justify-content-end">
                    <div class="page-size-selector-top">
                        <select id="pageSizeSelect" class="form-select form-select-sm page-size-dropdown" @bind="_pageSize" @bind:after="OnPageSizeChanged" style="width: auto;" title="Items per page">
                            <option value="10">10 per page</option>
                            <option value="25">25 per page</option>
                            <option value="50">50 per page</option>
                            <option value="100">100 per page</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

<div class="collections-table-wrapper">
    <table class="table collections-table">
        <thead>
            <tr>
                <th class="sortable-header @GetSortClass("DatabaseName")" @onclick='() => SortBy("DatabaseName")' style="cursor: pointer;">
                    Database Name
                    <i class="bi @GetSortIcon("DatabaseName") ms-1"></i>
                </th>
                <th class="sortable-header @GetSortClass("CollectionName")" @onclick='() => SortBy("CollectionName")' style="cursor: pointer;">
                    Collection Name
                    <i class="bi @GetSortIcon("CollectionName") ms-1"></i>
                </th>
                @if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.JobType==OnlineMongoMigrationProcessor.Models.JobType.DumpAndRestore)
                {
                    <th class="sortable-header @GetSortClass("DownloadStatus")" @onclick='() => SortBy("DownloadStatus")' style="cursor: pointer;">
                        Download Status
                        <i class="bi @GetSortIcon("DownloadStatus") ms-1"></i>
                    </th>
                    <th class="sortable-header @GetSortClass("UploadStatus")" @onclick='() => SortBy("UploadStatus")' style="cursor: pointer;">
                        Upload Status
                        <i class="bi @GetSortIcon("UploadStatus") ms-1"></i>
                    </th>
                }
                else
                {
                    <th class="sortable-header @GetSortClass("CopyStatus")" @onclick='() => SortBy("CopyStatus")' style="cursor: pointer;">
                        Copy Status
                        <i class="bi @GetSortIcon("CopyStatus") ms-1"></i>
                    </th>
                }
                @if (CurrentlyLoadedMigrationJob != null && Helper.IsOnline(CurrentlyLoadedMigrationJob) && !CurrentlyLoadedMigrationJob.ProcessingSyncBack)
                {
                    @if (CurrentlyLoadedMigrationJob.JobType != OnlineMongoMigrationProcessor.Models.JobType.RUOptimizedCopy)
                    {
                        <th class="sortable-header @GetSortClass("TimeSinceLastChange")" @onclick='() => SortBy("TimeSinceLastChange")' style="cursor: pointer;">
                            Time Since Last Change
                            <i class="bi @GetSortIcon("TimeSinceLastChange") ms-1"></i>
                        </th>
                        <th class="sortable-header @GetSortClass("TimeSinceLastBatch")" @onclick='() => SortBy("TimeSinceLastBatch")' style="cursor: pointer;">
                            CS Last Checked
                            <i class="bi @GetSortIcon("TimeSinceLastBatch") ms-1"></i>
                        </th>
                        <th class="sortable-header @GetSortClass("LastBatchChanges")" @onclick='() => SortBy("LastBatchChanges")' style="cursor: pointer;">
                            Last Batch – Total Changes
                            <i class="bi @GetSortIcon("LastBatchChanges") ms-1"></i>
                        </th>
                    }
                    else
                    {
                        <th class="sortable-header @GetSortClass("LastBatchChanges")" @onclick='() => SortBy("LastBatchChanges")' style="cursor: pointer;">
                            Change Stream Last Batch – Total Changes
                            <i class="bi @GetSortIcon("LastBatchChanges") ms-1"></i>
                        </th>
                    }

                }
                @if (CurrentlyLoadedMigrationJob != null && Helper.IsOnline(CurrentlyLoadedMigrationJob) && CurrentlyLoadedMigrationJob.ProcessingSyncBack)
                {

                     <th class="sortable-header @GetSortClass("TimeSinceLastChange")" @onclick='() => SortBy("TimeSinceLastChange")' style="cursor: pointer;">
                        Time Since Last Sync Back
                        <i class="bi @GetSortIcon("TimeSinceLastChange") ms-1"></i>
                    </th>
                    <th class="sortable-header @GetSortClass("TimeSinceLastBatch")" @onclick='() => SortBy("TimeSinceLastBatch")' style="cursor: pointer;">
                        CS Last Checked
                        <i class="bi @GetSortIcon("TimeSinceLastBatch") ms-1"></i>
                    </th>
                    <th class="sortable-header @GetSortClass("LastBatchChanges")" @onclick='() => SortBy("LastBatchChanges")' style="cursor: pointer;">
                        Last Batch – Total Changes
                        <i class="bi @GetSortIcon("LastBatchChanges") ms-1"></i>
                    </th>
                }
            </tr>
        </thead>
        <tbody>
            @if (!_isLoadingCollections && CurrentlyLoadedMigrationJob.MigrationUnitBasics != null && GetFilteredAndPagedUnits().Any())
            {
                @foreach (var mu in GetFilteredAndPagedUnits())
                {
                    <tr>
                        <td>
                            <i class="bi bi-info-circle-fill me-2 collection-info-icon" title="More info" style="cursor: pointer;"
                               @onclick="() => ShowCollectionDetails(mu)"></i>
                            <i class="bi bi-download me-2 collection-info-icon" title="Download JSON" style="cursor: pointer;"
                               @onclick="() => DownloadMigrationUnit(mu)"></i>
                            @mu.DatabaseName
                        </td>
                        <td>@mu.CollectionName</td>
                        <td>
                            @(mu.SourceStatus == CollectionStatus.NotFound ? "Skipped (404)"
                                                : mu.SourceStatus == CollectionStatus.IsView ? "Skipped (VIEW)"
                                                : (mu.DumpComplete ? "Success" : $"{mu.DumpPercent:F1}%"))

                        </td>

                        @if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.JobType == OnlineMongoMigrationProcessor.Models.JobType.DumpAndRestore)
                        {
                            <td>
                                @(mu.SourceStatus == CollectionStatus.NotFound ? "Skipped (404)"
                                                    : mu.SourceStatus == CollectionStatus.IsView ? "Skipped (VIEW)"
                                                    : (mu.RestoreComplete || mu.RestorePercent == 100 ? "Success" : $"{mu.RestorePercent:F1}%"))

                            </td>
                        }
                        @if (CurrentlyLoadedMigrationJob != null && Helper.IsOnline(CurrentlyLoadedMigrationJob))
                        {
                            @if (CurrentlyLoadedMigrationJob.JobType != OnlineMongoMigrationProcessor.Models.JobType.RUOptimizedCopy || CurrentlyLoadedMigrationJob.ProcessingSyncBack)
                            {
                                <td title="Avg Read Latency: @mu.CSAvgReadLatencyInMS.ToString("F2") ms | Avg Write Latency: @mu.CSAvgWriteLatencyInMS.ToString("F2") ms">                           
                                    @Helper.GetTimestampDiff(mu, CurrentlyLoadedMigrationJob.ProcessingSyncBack)
                                </td>
                                <td>
                                    @GetTimeSinceLastBatch(CurrentlyLoadedMigrationJob, mu)
                                </td>
                            }
                            <td>
                                @mu.CSUpdatesInLastBatch
                            </td>
                        }
                    </tr>
                }
            }
            else if (!_isLoadingCollections && @CurrentlyLoadedMigrationJob.MigrationUnitBasics!= null && !string.IsNullOrWhiteSpace(_filterText))
            {
                <tr>
                    <td colspan="10" class="empty-collections-state">
                        <i class="bi bi-search"></i>
                        <h5>No collections match your filter</h5>
                        <p>Try adjusting your search terms or <button class="btn btn-link p-0" @onclick="ClearFilter">clear the filter</button></p>
                    </td>
                </tr>
            }
            else if (!_isLoadingCollections && (@CurrentlyLoadedMigrationJob.MigrationUnitBasics == null || !@CurrentlyLoadedMigrationJob.MigrationUnitBasics.Any()))
            {
                <tr>
                    <td colspan="10" class="empty-collections-state">
                        <i class="bi bi-collection"></i>
                        <h5>No collections configured</h5>
                        <p>Use the "Update Collections" button below to add collections to this migration job.</p>
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

@* Pagination Controls *@
@if (!_isLoadingCollections && GetTotalPages() > 1)
{
    <nav aria-label="Collections pagination" class="mt-3">
        <ul class="pagination justify-content-center">
            <li class="page-item @(IsFirstPage() ? "disabled" : "")">
                <button class="page-link" @onclick="() => GoToPage(1)" disabled="@IsFirstPage()" title="First page">
                    <i class="bi bi-chevron-double-left"></i>
                </button>
            </li>
            <li class="page-item @(IsFirstPage() ? "disabled" : "")">
                <button class="page-link" @onclick="() => GoToPage(_currentPage - 1)" disabled="@IsFirstPage()" title="Previous page">
                    <i class="bi bi-chevron-left"></i>
                </button>
            </li>

            @for (int page = GetStartPage(); page <= GetEndPage(); page++)
            {
                var pageNumber = page;
                <li class="page-item @(_currentPage == pageNumber ? "active" : "")">
                    <button class="page-link" @onclick="() => GoToPage(pageNumber)" title="Go to page @pageNumber">
                        @pageNumber
                    </button>
                </li>
            }

            <li class="page-item @(IsLastPage() ? "disabled" : "")">
                <button class="page-link" @onclick="() => GoToPage(_currentPage + 1)" disabled="@IsLastPage()" title="Next page">
                    <i class="bi bi-chevron-right"></i>
                </button>
            </li>
            <li class="page-item @(IsLastPage() ? "disabled" : "")">
                <button class="page-link" @onclick="() => GoToPage(GetTotalPages())" disabled="@IsLastPage()" title="Last page">
                    <i class="bi bi-chevron-double-right"></i>
                </button>
            </li>
        </ul>
        
        <div class="text-center mt-2">
            <small class="text-muted">
                Page @_currentPage of @GetTotalPages() 
                (@GetFilteredItemsCount() @(GetFilteredItemsCount() == 1 ? "collection" : "collections"))
            </small>
        </div>
    </nav>
}

@if(!_isLoadingCollections && (IsPauseEnabled() || IsResumeEnabled()))
{
    <div class="d-flex align-items-center mb-3 mt-4">
        <button class="btn btn-primary mx-2" title="You can add or remove collections from this job. Be sure to pause the job before doing so." @onclick="ManageCollections" disabled="@_isLoadingCollections">Update Collections</button>
        @if (CurrentlyLoadedMigrationJob != null && Helper.IsOnline(CurrentlyLoadedMigrationJob))
        {
            <button class="btn btn-warning mx-2" title="Reset the change stream checkpoint to start from the beginning. This may add extra load to the migration process and could delay other collections. Ensure the job is paused before continuing." @onclick="ResetChangeStream">
                @(((@CurrentlyLoadedMigrationJob.MigrationUnitBasics ?? new List<MigrationUnitBasic>()).Any(MigrationUnit => MigrationUnit.ResetChangeStream)) ? "✓ Reset Change Stream" : "☐ Reset Change Stream")
            </button>

            @if (CurrentlyLoadedMigrationJob?.JobType != OnlineMongoMigrationProcessor.Models.JobType.RUOptimizedCopy)
            {
                <button class="btn btn-warning mx-2" title="Compare randomly selected documents from collections in the source and target accounts to identify any discrepancies or missing entries. Be sure to pause the job before doing so." @onclick="RunComparison">
                    @((CurrentlyLoadedMigrationJob?.RunComparison ?? false) ? "✓ Run Hash Check" : "☐ Run Hash Check")
                </button>
            }
        }
    
    </div>
}

@if ((CurrentlyLoadedMigrationJob?.AutoRefreshEnabled ?? true) && LogBucket != null && VerboseMessages != null && VerboseMessages.Count > 0 && !_showLogBackupFile)
{
    <h5 class="pt-4">
        Monitor
    </h5>
    <div>
        <table class="table message-output">
            <tbody>
                @foreach (var logObject in VerboseMessages)
                {
                    <tr>
                        <td>
                            @if(string.IsNullOrEmpty(logObject.Message))
                            {
                                <span>&nbsp;</span>
                            }
                            else
                            {
                                <span>@logObject.Datetime - @logObject.Message</span>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@if (LogBucket != null && LogBucket.Logs != null && !_showLogBackupFile)
{
    <div class="d-flex justify-content-between align-items-center pt-4">
        <h5 class="mb-0">
            <button class="btn btn-light" @onclick="DownloadFile" title="Download Log File" style="border: none; background: transparent;">
                <i class="bi bi-download"></i>
            </button> Logs
        </h5>
        <div class="d-flex align-items-center">
            <label class="me-2 mb-0" style="font-weight: normal;">Currently Logging:</label>
            <select class="form-select form-select-sm" style="width: auto;" value="@(CurrentlyLoadedMigrationJob?.LogLevel ?? LogType.Info)" @onchange="OnLogLevelChanged">
                <option value="@LogType.Error">Error Only</option>
                <option value="@LogType.Warning">Warning + Error</option>
                <option value="@LogType.Info">Info + Warning + Error</option>
                <option value="@LogType.Debug">Debug + Info + Warning + Error</option>
                <option value="@LogType.Verbose">All (Verbose)</option>
            </select>
        </div>
    </div>


    <table class="table console-output mt-2">
        <thead>
            <tr>
                <th class="log-icon-header"></th>
                <th style="width: 150px;">Date Time (UTC)</th>
                <th>Message</th>
            </tr>
        </thead>
        <tbody>

            @foreach (var logObject in LogBucket.Logs.TakeLast(200).Reverse())  // Reverse the last 200 items
            {
                <tr class="@GetRowClass(logObject.Type.ToString(),logObject.Message)">
                    <td class="log-icon-cell">@GetLogIcon(logObject.Type)</td>
                    <td>@logObject.Datetime</td>
                    <td>@logObject.Message</td>
                </tr>
            }                

            @if (LogBucket.Logs.Count > 250)
            {
                <tr>
                    <td></td>
                    <td> ....</td>
                    <td> ..... </td>
                </tr>

                @foreach (var logObject in LogBucket.Logs.Take(30).Reverse()) // Reverse the top 30 items
                {
                    <tr class="@GetRowClass(logObject.Type.ToString(),logObject.Message)">
                        <td class="log-icon-cell">@GetLogIcon(logObject.Type)</td>
                        <td style="width: 120px;">@logObject.Datetime</td>
                        <td>@logObject.Message</td>
                    </tr>
                }
            }
        </tbody>
    </table>


}
else if (@_showLogBackupFile)
{
    <div class="alert alert-danger">
        <p>
            Failed to load the log file. It appears to be corrupt and has been backed up.
            Use the button below to download the previous log. A new log file will be created
            when the job is resumed.
        </p>
        <button class="btn btn-primary mx-2"
                @onclick="DownloadLogBackupFile"
                title="Download Log File">
            Download Backup File
        </button>
    </div>
}
@code {
    [Parameter]
    public string JobId { get; set; } = string.Empty;

    // private CurrentlyLoadedMigrationJob _migrationJob;

    // [Parameter]
    // CurrentlyLoadedMigrationJob property that checks for active job context
    public MigrationJob? CurrentlyLoadedMigrationJob
    {   get
        {
            // if (_migrationJob != null && _migrationJob.Id == MigrationJobContext.ActiveMigrationJobId)
            //     return MigrationJobContext.CurrentlyActiveJob;
            // else
            //     return _migrationJob;

            return MigrationJobContext.GetMigrationJob(JobId);
        }
        // private set { }
        // }
    }

    private LogBucket? LogBucket { get; set; }
    private List<LogObject> VerboseMessages { get; set; } = new();

    private string _errorMessage = string.Empty;
    private bool _migrationDetailsPopUpOpen;
    private Timer? _refreshTimer;
    private string _message = string.Empty;
    private bool _yesNoDialogOpen;
    private YesNoDialog.Category _yesNoDiaLogType= YesNoDialog.Category.CutoverNot;
    private bool _manageCollectionDialogOpen;
    private bool _resetChangeStreamDialogOpen;
    private bool _collectionDetailsDialogOpen;

    private bool _showLogBackupFile = false;
    private string _logBackupFile = string.Empty;
    private MigrationUnitBasic? _selectedMigrationUnit;

    // Paginated download fields
    private bool _showPaginatedDownloadDialog = false;
    private int _logEntryCount = 0;
    private OnlineMongoMigrationProcessor.MigrationSettings? _config;

    // Loading spinner state for collection loading
    private bool _isLoadingCollections = false;

    // Pagination and filtering properties (kept for UI binding compatibility)
    private string _filterText = string.Empty;
    private int _currentPage = 1;
    private int _pageSize = 10;

    // Sorting properties
    private string _sortColumn = "DatabaseName";
    private bool _sortAscending = true;

    // Pagination helper
    private PaginationHelper<MigrationUnitBasic> _paginationHelper = new PaginationHelper<MigrationUnitBasic>(
        new List<MigrationUnitBasic>(),
        (mu, filterText) => true // Simple predicate, will be updated in UpdatePaginationHelper
    );

    // Cache to prevent re-sorting/filtering on every render
    private List<MigrationUnitBasic>? _cachedFilteredAndPagedUnits = null;
    private int _cachedFilteredItemsCount = 0;
    private string _cachedDisplayedItemsInfo = string.Empty;
    private int _cachedTotalPages = 0;
    private int _lastMigrationUnitsCount = 0;
    private string _lastSortColumn = string.Empty;
    private bool _lastSortAscending = true;
    private string _lastFilterText = string.Empty;
    private int _lastPageSize = 0;
    private int _lastCurrentPage = 0;

    private Func<MigrationUnitBasic, string, bool> GetFilterPredicate()
    {
        return (mu, filterText) =>
        {
            // Return true if any of the column values match the filter text
            if (string.IsNullOrWhiteSpace(filterText))
                return true;

            var searchText = filterText.ToLower();

            // Database Name
            if (mu.DatabaseName.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                return true;

            // Collection Name
            if (mu.CollectionName.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                return true;

            // Database.Collection combined
            if ($"{mu.DatabaseName}.{mu.CollectionName}".Contains(searchText, StringComparison.OrdinalIgnoreCase))
                return true;

            // Source Status / Download Status
            var sourceStatus = mu.SourceStatus == CollectionStatus.NotFound ? "Skipped (404)"
                                                : mu.SourceStatus == CollectionStatus.IsView ? "Skipped (VIEW)"
                                                : (mu.DumpComplete ? "Success" : $"{mu.DumpPercent:F1}%");
            if (sourceStatus.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                return true;

            // Upload/Restore Status (for DumpAndRestore jobs)
            if (CurrentlyLoadedMigrationJob?.JobType == OnlineMongoMigrationProcessor.Models.JobType.DumpAndRestore)
            {
                var uploadStatus = mu.SourceStatus == CollectionStatus.NotFound ? "Skipped (404)"
                                                    : mu.SourceStatus == CollectionStatus.IsView ? "Skipped (VIEW)"
                                                    : (mu.RestoreComplete || mu.RestorePercent == 100 ? "Success" : $"{mu.RestorePercent:F1}%");
                if (uploadStatus.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            // Change Stream Lag (Time Since Last Change/Sync Back)
            if (CurrentlyLoadedMigrationJob!=null & Helper.IsOnline(CurrentlyLoadedMigrationJob) == true)
            {
                var lagText = Helper.GetTimestampDiff(mu, CurrentlyLoadedMigrationJob.ProcessingSyncBack);
                if (lagText.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            // Last Batch Changes Count
            if (Helper.IsOnline(CurrentlyLoadedMigrationJob) == true)
            {
                var batchCount = mu.CSUpdatesInLastBatch.ToString();
                if (batchCount.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            // Collection Status text variants
            if (mu.SourceStatus == CollectionStatus.NotFound && 
                ("missing".Contains(searchText) || "empty".Contains(searchText) || "notfound".Contains(searchText)))
                return true;

            if ((mu.DumpComplete && "success".Contains(searchText)) || 
                (mu.RestoreComplete && "success".Contains(searchText)))
                return true;

            // Percentage values
            if (searchText.Contains("%"))
            {
                var percentText = searchText.Replace("%", "").Trim();
                if (double.TryParse(percentText, out var searchPercent))
                {
                    if (Math.Abs(mu.DumpPercent - searchPercent) < 0.1)
                        return true;
                    if (Math.Abs(mu.RestorePercent - searchPercent) < 0.1)
                        return true;
                }
            }

            return false;
        };
    }

    #region Sorting Methods

    private async Task SortBy(string columnName)
    {
        if (_sortColumn == columnName)
        {
            _sortAscending = !_sortAscending;
        }
        else
        {
            _sortColumn = columnName;
            _sortAscending = true;
        }

        _currentPage = 1; // Reset to first page when sorting changes
        await InvokeAsync(StateHasChanged);
    }

    private string GetSortIcon(string columnName)
    {
        if (_sortColumn != columnName)
            return "bi-arrow-down-up"; // Neutral sort icon

        return _sortAscending ? "bi-arrow-up" : "bi-arrow-down";
    }

    private string GetSortClass(string columnName)
    {
        return _sortColumn == columnName ? "sorted-column" : "";
    }

    private List<MigrationUnitBasic> ApplySorting(List<MigrationUnitBasic> units)
    {
        if (units == null || !units.Any())
            return units ?? new List<MigrationUnitBasic>();

        return _sortColumn switch
        {
            "DatabaseName" => _sortAscending 
                ? units.OrderBy(u => u.DatabaseName).ToList()
                : units.OrderByDescending(u => u.DatabaseName).ToList(),

            "CollectionName" => _sortAscending
                ? units.OrderBy(u => u.CollectionName).ToList()
                : units.OrderByDescending(u => u.CollectionName).ToList(),

            "DownloadStatus" or "CopyStatus" => _sortAscending
                ? units.OrderBy(u => GetSortValueForStatus(u, false)).ToList()
                : units.OrderByDescending(u => GetSortValueForStatus(u, false)).ToList(),

            "UploadStatus" => _sortAscending
                ? units.OrderBy(u => GetSortValueForStatus(u, true)).ToList()
                : units.OrderByDescending(u => GetSortValueForStatus(u, true)).ToList(),

            "TimeSinceLastChange" => _sortAscending
                ? units.OrderBy(u => GetSortValueForTimestamp(u)).ToList()
                : units.OrderByDescending(u => GetSortValueForTimestamp(u)).ToList(),

            "TimeSinceLastBatch" => _sortAscending
                ? units.OrderBy(u => GetSortValueForLastBatch(u)).ToList()
                : units.OrderByDescending(u => GetSortValueForLastBatch(u)).ToList(),

            "LastBatchChanges" => _sortAscending
                ? units.OrderBy(u => u.CSUpdatesInLastBatch).ToList()
                : units.OrderByDescending(u => u.CSUpdatesInLastBatch).ToList(),

            _ => units
        };
    }

    private object GetSortValueForStatus(MigrationUnitBasic mu, bool isUploadStatus)
    {
        if (mu.SourceStatus == CollectionStatus.NotFound)
            return "0_Skipped (404)"; // Sort skipped items first

        if (mu.SourceStatus == CollectionStatus.IsView)
            return "0_Skipped (VIEW)"; // Sort skipped items first

        if (isUploadStatus)
        {
            if (mu.RestoreComplete || mu.RestorePercent == 100)
                return "2_Success"; // Sort completed items last
            return $"1_{mu.RestorePercent:000.0}%"; // Sort by percentage in middle
        }
        else
        {
            if (mu.DumpComplete)
                return "2_Success"; // Sort completed items last
            return $"1_{mu.DumpPercent:000.0}%"; // Sort by percentage in middle
        }
    }

    private DateTime GetSortValueForTimestamp(MigrationUnitBasic mu)
    {
        if (CurrentlyLoadedMigrationJob?.ProcessingSyncBack == true)
            return mu.SyncBackCursorUtcTimestamp;
        else
            return mu.CursorUtcTimestamp;
    }


    

    private string GetTimeSinceLastBatch(MigrationJob job,MigrationUnitBasic mu)
    {
        if (job.ChangeStreamLevel == OnlineMongoMigrationProcessor.Models.ChangeStreamLevel.Server)
        {
            if (job.CSLastChecked == null || job.CSLastChecked == DateTime.MinValue)
                return "NA";
            else
                return Helper.GetTimestampDiff(job.CSLastChecked.Value);
        }

        MigrationUnit migrationUnit = MigrationJobContext.GetMigrationUnit(mu.Id, job.Id);

        if (migrationUnit == null || migrationUnit.CSLastChecked == null || migrationUnit.CSLastChecked == DateTime.MinValue)
            return "NA";

        return Helper.GetTimestampDiff(migrationUnit.CSLastChecked.Value);
    }

    private DateTime GetSortValueForLastBatch(MigrationUnitBasic mu)
    {
        MigrationUnit migrationUnit = MigrationJobContext.GetMigrationUnit(mu.Id, CurrentlyLoadedMigrationJob.Id);

        if (migrationUnit == null || migrationUnit.CSLastChecked == null || migrationUnit.CSLastChecked == DateTime.MinValue)
            return DateTime.MinValue;

        return migrationUnit.CSLastChecked.Value;
    }

    #endregion

    #region Pagination and Filtering Methods

    private void UpdatePaginationHelper()
    {
        // Check if we need to invalidate the cache
        var currentUnitsCount = @CurrentlyLoadedMigrationJob.MigrationUnitBasics?.Count ?? 0;
        bool needsUpdate = _cachedFilteredAndPagedUnits == null ||
                          currentUnitsCount != _lastMigrationUnitsCount ||
                          _sortColumn != _lastSortColumn ||
                          _sortAscending != _lastSortAscending ||
                          _filterText != _lastFilterText ||
                          _pageSize != _lastPageSize ||
                          _currentPage != _lastCurrentPage;

        if (!needsUpdate)
        {
            return; // Use cached data
        }

        var currentUnits = @CurrentlyLoadedMigrationJob.MigrationUnitBasics ?? new List<MigrationUnitBasic>();

        // Apply sorting before pagination
        currentUnits = ApplySorting(currentUnits);

        // Recreate the pagination helper only when needed
        _paginationHelper = new PaginationHelper<MigrationUnitBasic>(
            currentUnits,
            GetFilterPredicate()
        );

        // Update the helper with current component state
        _paginationHelper.FilterText = _filterText;
        _paginationHelper.PageSize = _pageSize;

        // Ensure current page is within valid bounds
        var totalPages = _paginationHelper.GetTotalPages();
        if (_currentPage > totalPages)
        {
            _currentPage = Math.Max(1, totalPages);
        }
        _paginationHelper.CurrentPage = _currentPage;

        // Cache the results to prevent redundant GetFilteredItems() calls
        _cachedFilteredAndPagedUnits = _paginationHelper.GetPagedItems();
        _cachedFilteredItemsCount = _paginationHelper.GetFilteredItemsCount();
        _cachedDisplayedItemsInfo = _paginationHelper.GetDisplayedItemsInfo();
        _cachedTotalPages = _paginationHelper.GetTotalPages();

        // Update tracking variables
        _lastMigrationUnitsCount = currentUnitsCount;
        _lastSortColumn = _sortColumn;
        _lastSortAscending = _sortAscending;
        _lastFilterText = _filterText;
        _lastPageSize = _pageSize;
        _lastCurrentPage = _currentPage;
    }

    private List<MigrationUnitBasic> GetFilteredAndPagedUnits()
    {
        UpdatePaginationHelper();
        return _cachedFilteredAndPagedUnits ?? new List<MigrationUnitBasic>();
    }

    private int GetTotalItemsCount()
    {
        return @CurrentlyLoadedMigrationJob.MigrationUnitBasics?.Count ?? 0;
    }

    private int GetFilteredItemsCount()
    {
        UpdatePaginationHelper();
        return _cachedFilteredItemsCount;
    }

    private string GetDisplayedItemsInfo()
    {
        UpdatePaginationHelper();
        return _cachedDisplayedItemsInfo;
    }

    private int GetTotalPages()
    {
        UpdatePaginationHelper();
        return _cachedTotalPages;
    }

    private bool IsFirstPage() 
    {
        UpdatePaginationHelper();
        return _paginationHelper.IsFirstPage();
    }

    private bool IsLastPage() 
    {
        UpdatePaginationHelper();
        return _paginationHelper.IsLastPage();
    }

    private int GetStartPage()
    {
        UpdatePaginationHelper();
        return _paginationHelper.GetStartPage();
    }

    private int GetEndPage()
    {
        UpdatePaginationHelper();
        return _paginationHelper.GetEndPage();
    }

    private async Task GoToPage(int pageNumber)
    {
        _currentPage = pageNumber;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnFilterChanged()
    {
        _currentPage = 1; // Reset to first page when filter changes
        await InvokeAsync(StateHasChanged);
    }

    private async Task ClearFilter()
    {
        _filterText = string.Empty;
        _currentPage = 1;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnPageSizeChanged()
    {
        _currentPage = 1; // Reset to first page when page size changes
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnLogLevelChanged(ChangeEventArgs e)
    {
        if (CurrentlyLoadedMigrationJob != null && Enum.TryParse<LogType>(e.Value?.ToString(), out var newLogLevel))
        {
            MigrationJobContext.UpdateLogLevel(newLogLevel, CurrentlyLoadedMigrationJob);
            await InvokeAsync(StateHasChanged);
        }
    }
    #endregion

    private string GetRowClass(string type, string message)
    {
        // Return CSS class based on LogType
        // Treat deprecated "Message" as "Info"
        return type switch
        {
            "Error" => "error-row",
            "Warning" => "warning-row",
            "Message" => "info-row",  // Deprecated, treat as Info
            "Info" => "info-row",
            "Debug" => "debug-row",
            "Verbose" => "verbose-row",
            _ => string.Empty
        };
    }

    private MarkupString GetLogIcon(LogType logType)
    {
        // Return Bootstrap icon based on LogType
        #pragma warning disable CS0618 // Type or member is obsolete
        return logType switch
        {
            LogType.Error => new MarkupString("<i class='bi bi-x-circle-fill'></i>"),
            LogType.Warning => new MarkupString("<i class='bi bi-exclamation-triangle-fill'></i>"),
            LogType.Message => new MarkupString("<i class='bi bi-info-circle-fill'></i>"),  // Deprecated, treat as Info
            LogType.Info => new MarkupString("<i class='bi bi-info-circle-fill'></i>"),
            LogType.Debug => new MarkupString("<i class='bi bi-bug-fill'></i>"),
            LogType.Verbose => new MarkupString("<i class='bi bi-chat-dots-fill'></i>"),
            _ => new MarkupString("")
        };
        #pragma warning restore CS0618
    }

    private void GoBack()
    {
        _refreshTimer?.Dispose();
        NavigationManager.NavigateTo("/"); // Navigate back to the previous page
    }

    private async Task ToggleAutoRefresh()
    {
        await InvokeAsync(() =>
        {
            CurrentlyLoadedMigrationJob.AutoRefreshEnabled = !CurrentlyLoadedMigrationJob.AutoRefreshEnabled;

            if (CurrentlyLoadedMigrationJob.AutoRefreshEnabled)
            {
                // Re-enable: Start the timer and do an immediate refresh
                if (_refreshTimer == null)
                {
                    _refreshTimer = new Timer(Refresh, null, 0, 5000); // Update every 5 seconds
                }

                // Trigger immediate refresh
                if (CurrentlyLoadedMigrationJob != null && (CurrentlyLoadedMigrationJob.IsStarted || JobManager.DidMigrationJobExitRecently(JobId)) && !_showLogBackupFile)
                {
                    if (_isLoadingCollections && @CurrentlyLoadedMigrationJob.MigrationUnitBasics != null && @CurrentlyLoadedMigrationJob.MigrationUnitBasics.Count > 0)
                    {
                        _isLoadingCollections = false;
                    }

                    LogBucket = JobManager.GetLogBucket(JobId, out string logBackup, out bool isLive);
                    if (!string.IsNullOrEmpty(logBackup) && logBackup != JobId)
                        _logBackupFile = logBackup;

                    VerboseMessages = JobManager.GetMonitorMessages(JobId ?? string.Empty);
                }
            }
            else
            {
                // Disable: Stop and dispose the timer
                _refreshTimer?.Dispose();
                _refreshTimer = null;
            }

            StateHasChanged();
        });
    }

    private void StartAutoRefresh()
    {
        _showLogBackupFile = false;
        _logBackupFile = string.Empty;  

        if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.IsStarted)
        {
            // Only start timer if AutoRefreshEnabled is true (default)
            if (CurrentlyLoadedMigrationJob.AutoRefreshEnabled)
            {
                _refreshTimer = new Timer(Refresh, null, 0, 5000); // Update every 5 seconds
            }
            ScheduleUpdateTimerStatus(JobId, 30); // check to set the timer status based on whether the job is live or not
        }

    }

    private void ShowCollectionDetails(MigrationUnitBasic mu)
    {
        _selectedMigrationUnit = mu;
        _collectionDetailsDialogOpen = true;
    }

    private List<MigrationJob> GetMigrations()
    {
        var ids = JobManager.GetMigrationIds();
        var list = MigrationJobContext.PopulateMigrationJobs(ids);
        return list;
    }

    private async Task DownloadLogBackupFile()
    {
        if (string.IsNullOrEmpty(_logBackupFile))
        {
            return;
        }
        await Downloader(_logBackupFile, $"Backup_{_logBackupFile}");
    }


    private async Task DownloadFile()
    {
        if (string.IsNullOrEmpty(JobId))
        {
            return;
        }

        // First check log count
        _logEntryCount = await GetLogCount(JobId);

        // Load config to get LogPageSize threshold
        _config ??= new OnlineMongoMigrationProcessor.MigrationSettings();
        _config.Load();
        int logThreshold = _config.LogPageSize;

        if (_logEntryCount > logThreshold)
        {
            // Show paginated download dialog
            _showPaginatedDownloadDialog = true;
            StateHasChanged();
        }
        else
        {
            // Direct download for small files
            await Downloader(JobId, JobId);
        }
    }

    private async Task DownloadMigrationUnit(MigrationUnitBasic mu)
    {
        if (string.IsNullOrEmpty(JobId) || string.IsNullOrEmpty(mu?.Id))
        {
            return;
        }

        var url = $"/api/File/download/migrationunit/{JobId}/{mu.Id}";
        var response = await HttpClient.GetAsync(url);

        if (response.IsSuccessStatusCode)
        {
            var fileBytes = await response.Content.ReadAsByteArrayAsync();
            var contentType = response.Content.Headers.ContentType?.ToString() ?? "application/octet-stream";
            var fileName = $"{mu.DatabaseName}_{mu.CollectionName}_{mu.Id}.json";

            // Use JavaScript to trigger the file download
            await JS.InvokeVoidAsync("downloadFile", fileBytes, fileName, contentType);
        }
        else
        {
            await JS.InvokeVoidAsync("open", url, "_blank"); // browser navigates directly
        }
    }

    private async Task Downloader(string fileName, string displayName)
    {

        var url = $"/api/File/download/log/{fileName}";

        var request = new HttpRequestMessage(HttpMethod.Get, url);      

        var response = await HttpClient.GetAsync(url);

        if (response.IsSuccessStatusCode)
        {
            var fileBytes = await response.Content.ReadAsByteArrayAsync();
            var contentType = response.Content.Headers.ContentType?.ToString() ?? "application/octet-stream";

            // Use JavaScript to trigger the file download
            await JS.InvokeVoidAsync("downloadFile", fileBytes, $"{displayName}.json", contentType);
        }
        else
        {
            await JS.InvokeVoidAsync("open", url, "_blank"); // browser navigates directly
        }
    }

    private async Task<int> GetLogCount(string jobId)
    {
        try
        {
            var url = $"/api/File/download/log/{jobId}/count";
            var response = await HttpClient.GetAsync(url);

            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsStringAsync();
                var result = System.Text.Json.JsonSerializer.Deserialize<LogCountResponse>(content);
                return result?.count ?? 0;
            }
        }
        catch { }

        return 0;
    }

    private void ClosePaginatedDownloadDialog()
    {
        _showPaginatedDownloadDialog = false;
        StateHasChanged();
    }


    private void Refresh(object? state)
    {
        // Marshal ALL component state changes to the UI thread to prevent cross-thread access issues
        InvokeAsync(() =>
        {

            if (CurrentlyLoadedMigrationJob != null && (CurrentlyLoadedMigrationJob.IsStarted || JobManager.DidMigrationJobExitRecently(JobId)) && !_showLogBackupFile)
            {
                // Check if we should hide loading spinner
                if (_isLoadingCollections && @CurrentlyLoadedMigrationJob.MigrationUnitBasics != null && @CurrentlyLoadedMigrationJob.MigrationUnitBasics.Count > 0)
                {
                    _isLoadingCollections = false;
                }

                LogBucket = JobManager.GetLogBucket(JobId, out string logBackup, out bool isLive);
                if (!string.IsNullOrEmpty(logBackup) && logBackup != JobId)
                    _logBackupFile = logBackup;

                VerboseMessages = JobManager.GetMonitorMessages(JobId ?? string.Empty);

                if (!string.IsNullOrEmpty(_logBackupFile))
                {
                    _refreshTimer?.Dispose();
                    _refreshTimer = null;
                    _showLogBackupFile = true;
                }
                else
                    _showLogBackupFile = false;

                // Invalidate all pagination caches when data refreshes
                _cachedFilteredAndPagedUnits = null;
                _cachedFilteredItemsCount = 0;
                _cachedDisplayedItemsInfo = string.Empty;
                _cachedTotalPages = 0;

                StateHasChanged();
            }
            else
            {    
                _refreshTimer?.Dispose();
            }
        });
    }

    private async Task UpdateTimerStatus(string id, int seconds)
    {
        await Task.Delay(TimeSpan.FromSeconds(seconds)); // Wait for the specified seconds before processing

        Console.WriteLine($"UpdateTimerStatus Invoked");

        if (id!= JobId)
        {
            return; // Exit if the JobId does not match
        }

        if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.IsStarted)
        {
            LogBucket = JobManager.GetLogBucket(id, out string logBackup, out bool isLive);
            if (!string.IsNullOrEmpty(logBackup) && logBackup != JobId)
                _logBackupFile = logBackup;

            if (!isLive)               
            {
                _refreshTimer?.Dispose(); // Stop the timer if not live
                _refreshTimer = null;
                //_showLogBackupFile = false;
            }
        }

    }

    private void ScheduleUpdateTimerStatus(string id, int seconds)
    {
        _ = Task.Run(async () => await UpdateTimerStatus(id, seconds));
    }

    private Task<bool> CheckIfNameExistsAsync(string name)
    {
        //always false as we are not checking for duplicate names in this case
        return Task.FromResult(false);
    }

    private bool CheckCutoverReadiness()
    {
        return Helper.IsOfflineJobCompleted(CurrentlyLoadedMigrationJob);
        // foreach (var mu in CurrentlyLoadedMigrationJob.MigrationUnitBasics)
        // {
        //     if (mu.SourceStatus != CollectionStatus.NotFound)
        //     {
        //         if (mu.DumpPercent != 100 || mu.RestorePercent != 100)
        //             return false;
        //     }
        // }
        // return true;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (CurrentlyLoadedMigrationJob == null) // Fixed the condition to check for null
        {
            return;
        }

        LogBucket = JobManager.GetLogBucket(JobId, out string logBackup, out bool isLive);
        if (!string.IsNullOrEmpty(logBackup) && logBackup != JobId)
            _logBackupFile = logBackup;

        if (!string.IsNullOrEmpty(_logBackupFile))
        {
            _showLogBackupFile = true;
        }
        else
        {
            _showLogBackupFile = false;
            if (IsResumeEnabled())
            {
                await ResumeJob();
            }
            var mjLocal = CurrentlyLoadedMigrationJob;
            if (mjLocal != null && !mjLocal.IsCancelled && !mjLocal.IsCompleted && IsJobRunning())// && CurrentlyLoadedMigrationJob.CurrentlyActive
            {
                StartAutoRefresh();
            }
        }        
    }

    private async Task<bool> OnMigrationDetailsPopUpSubmit(MigrationJob? job, string sourceConnectionString, string targetConnectionString)
    {
        _migrationDetailsPopUpOpen = false;
        await Task.Delay(100);

        if (job == null || CurrentlyLoadedMigrationJob == null)
        {
            await InvokeAsync(StateHasChanged);
            return false;
        }

        if (!string.IsNullOrEmpty(sourceConnectionString))
            MigrationJobContext.SourceConnectionString[CurrentlyLoadedMigrationJob.Id] = sourceConnectionString;

        if (!string.IsNullOrEmpty(targetConnectionString))
            MigrationJobContext.TargetConnectionString[CurrentlyLoadedMigrationJob.Id] = targetConnectionString;

        // CurrentlyLoadedMigrationJob.CurrentlyActive = true;
        CurrentlyLoadedMigrationJob.IsCancelled = false;

        if (!CurrentlyLoadedMigrationJob.StartedOn.HasValue)
            CurrentlyLoadedMigrationJob.StartedOn = DateTime.UtcNow;

        CurrentlyLoadedMigrationJob.IsStarted = true;

        //var jobList = JobManager.GetJobList();
        MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob);
        MigrationJobContext.SaveJobList();


        // Check if we should show the loading spinner
        if (CurrentlyLoadedMigrationJob.MigrationUnitBasics == null || CurrentlyLoadedMigrationJob.MigrationUnitBasics.Count == 0)
        {
            _isLoadingCollections = true;
            await InvokeAsync(StateHasChanged);
        }

        // Fire-and-forget: Run the long task on a separate thread without blocking
        _ = Task.Run(async () =>
        {
            // JobManager.DisposeLogs();

            if (CurrentlyLoadedMigrationJob.ProcessingSyncBack && !CurrentlyLoadedMigrationJob.IsSimulatedRun)
            {
                await JobManager.SyncBackToSource(
                    MigrationJobContext.SourceConnectionString[CurrentlyLoadedMigrationJob.Id] ?? string.Empty,
                    MigrationJobContext.TargetConnectionString[CurrentlyLoadedMigrationJob.Id] ?? string.Empty, 
                    CurrentlyLoadedMigrationJob);
            }
            else
            {
                await JobManager.StartMigration(CurrentlyLoadedMigrationJob,
                    MigrationJobContext.SourceConnectionString[CurrentlyLoadedMigrationJob.Id] ?? string.Empty,
                    MigrationJobContext.TargetConnectionString[CurrentlyLoadedMigrationJob.Id] ?? string.Empty,
                    CurrentlyLoadedMigrationJob.NameSpaces ?? string.Empty,
                    CurrentlyLoadedMigrationJob.JobType,
                    Helper.IsOnline(CurrentlyLoadedMigrationJob));
            }
        });

        StartAutoRefresh();
        return true;
    }

    private void RunComparison()
    {
        _errorMessage = string.Empty;

        // Check if SourceConnectionString is blank
        if (string.IsNullOrWhiteSpace(MigrationJobContext.SourceConnectionString[CurrentlyLoadedMigrationJob.Id]))
        {
            _errorMessage = "Source connection string is not available. Please use 'Resume Job' → 'With Updated Connection Strings' to provide connection details, then pause the job before running comparison.";
            return;
        }

        if (IsResumeEnabled())
        {
            _yesNoDiaLogType=YesNoDialog.Category.RunComparisonNot;
            _message = "Comparing collections using random sampling may take some time. This process will block the migration and could cause delays. Please confirm if you want to continue with the comparison. You will need to resume the job to continue.";
            _yesNoDialogOpen = true;

        }
        else
        {
            _errorMessage = "Please pause the job before you run the comparison.";
        }
    }

    private void ResetChangeStream()
    {
        _errorMessage = string.Empty;

        if (IsResumeEnabled() && !(CurrentlyLoadedMigrationJob?.ProcessingSyncBack ?? false))
        {
            _resetChangeStreamDialogOpen = true;
        }
        else
        {
            if (CurrentlyLoadedMigrationJob?.ProcessingSyncBack ?? false)
                _errorMessage = "You cannot reset change stream after sync back has started.";
            else
                _errorMessage = "Please pause the job before resetting change stream.";
        }
    }
    private void ManageCollections()
    {
        _errorMessage = string.Empty;

        // Check if SourceConnectionString is blank
        if (string.IsNullOrWhiteSpace(MigrationJobContext.SourceConnectionString[CurrentlyLoadedMigrationJob.Id]))
        {
            _errorMessage = "Source connection string is not available. Please use 'Resume Job' → 'With Updated Connection Strings' to provide connection details, then pause the job before updating collections.";
            return;
        }

        if (IsResumeEnabled() && !(CurrentlyLoadedMigrationJob?.ProcessingSyncBack ?? false))
        {
            _manageCollectionDialogOpen = true;
        }
        else
        {
            if (CurrentlyLoadedMigrationJob?.ProcessingSyncBack ?? false)
                _errorMessage = "You cannot update collections after sync back has started.";
            else
                _errorMessage = "Please pause the job before updating collections.";
        }
    }
    private async Task ResumeJobWithNewConnectionString()
    {
        await DecideAndResumeJob(true);
    }

    private async Task ResumeJobWithExistingConnectionString()
    {
        if (IsResumeEnabled() && NoOtherActiveJobs())
        {
            if (CurrentlyLoadedMigrationJob != null)
                await OnMigrationDetailsPopUpSubmit(CurrentlyLoadedMigrationJob, string.Empty, string.Empty);
            else
                _migrationDetailsPopUpOpen = true;
        }
        else
            _migrationDetailsPopUpOpen = true;
    }

    private async Task ResumeJob()
    {
        await DecideAndResumeJob(false);
    }

    private async Task DecideAndResumeJob(bool showDialog=false)
    {
        _errorMessage = string.Empty;
        if (IsResumeEnabled() && NoOtherActiveJobs())
        {
            if(showDialog)
                _migrationDetailsPopUpOpen = true;
            else
            {
                if (CanAutoStart())
                {
                    if (CurrentlyLoadedMigrationJob != null)
                        await OnMigrationDetailsPopUpSubmit(CurrentlyLoadedMigrationJob, string.Empty, string.Empty);
                }

            }
        }
        else
        {
            _errorMessage = "Please stop active job, before starting/resuming a job.";
        }
    }

    private bool IsJobRunning()
    {
        return JobManager.IsProcessRunning(JobId);
    }

    private void InitSyncBackJob()
    {
        _message = "You are about to initiate cutover and begin syncing data back to the source. Proceed only if all changes from the source have already been replicated to the target. This action is irreversible. Are you sure you want to cutover?";
        _yesNoDiaLogType = YesNoDialog.Category.SyncBackNot;
        _yesNoDialogOpen = true;      
    }

    private void CompleteJob()
    {
        if (CurrentlyLoadedMigrationJob?.ProcessingSyncBack ?? false)
        {
            _message = "You can't resume a job after its completed. Are you sure you want to complete the job?";
            _yesNoDiaLogType = YesNoDialog.Category.CompleteNot;
        }
        else
        {
            _message = "You can't resume a job after its cutover. Are you sure you want to cutover?";
            _yesNoDiaLogType = YesNoDialog.Category.CutoverNot;
        }
        _yesNoDialogOpen = true;
    }


    private void HandleCollectionDetailsClose()
    {
        _collectionDetailsDialogOpen = false;
        _selectedMigrationUnit = null;     
    }

    private void OnCSReset(List<MigrationUnit> migrationUnits)
    {
        _resetChangeStreamDialogOpen = false;

        if (migrationUnits != null && CurrentlyLoadedMigrationJob?.MigrationUnitBasics != null)
        {
            var migrationUnitsToReset = JobManager.GetMigrationUnits(CurrentlyLoadedMigrationJob);
            var migrationUnitIdsToReset = migrationUnits.Select(mu => mu.Id).ToHashSet();
            for (int i = 0; i < migrationUnitsToReset.Count; i++)
            {
                if (migrationUnitIdsToReset.Contains(migrationUnitsToReset[i].Id))
                    migrationUnitsToReset[i].ResetChangeStream = true; // Reset change stream for every second collection
                else
                    migrationUnitsToReset[i].ResetChangeStream = false; // Ensure other collections are not reset

                migrationUnitsToReset[i].ParentJob = CurrentlyLoadedMigrationJob;
                migrationUnitsToReset[i].UpdateParentJob();

                MigrationJobContext.SaveMigrationUnit(migrationUnitsToReset[i],false);
            }

            if (MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob))
                return;
        }
    }


    private async void OnCollectionsUpdated(List<MigrationUnit> migrationUnits)
    {
        _manageCollectionDialogOpen = false;

        if (migrationUnits != null && CurrentlyLoadedMigrationJob != null)
        {
            // Get IDs for comparison
            var existingIds = CurrentlyLoadedMigrationJob.MigrationUnitBasics.Select(mu => mu.Id).ToHashSet();
            var newIds = migrationUnits.Select(mu => mu.Id).ToHashSet();

            //get ids that are no llonger present in newUnits
            var delList = CurrentlyLoadedMigrationJob.MigrationUnitBasics.FindAll(mu => !newIds.Contains(mu.Id));

            foreach (var tobDel in delList)
            {
                tobDel.ParentJob = CurrentlyLoadedMigrationJob;
                tobDel.Remove();
                MigrationJobContext.MigrationUnitsCache.RemoveMigrationUnit(tobDel.Id);//remove from cache
            }

            foreach (var mu in migrationUnits)
            {
                mu.ParentJob = CurrentlyLoadedMigrationJob;                
            }

            // Add new units that don’t exist in existingUnits
            // foreach (var mu in migrationUnits)
            // {
            //     if (!CurrentlyLoadedMigrationJob.MigrationUnitBasics.Any(x => x.DatabaseName == mu.DatabaseName && x.CollectionName == mu.CollectionName))
            //     {
            //         MigrationJobContext.SaveMigrationUnit(mu,false);
            //         //CurrentlyLoadedMigrationJob.MigrationUnitBasics.Add(mu.GetBasic());
            //         Helper.AddMigrationUnit(mu, CurrentlyLoadedMigrationJob);
            //     }
            // }
            Helper.AddMigrationUnits(migrationUnits, CurrentlyLoadedMigrationJob);

            CurrentlyLoadedMigrationJob.NameSpaces = string.Join(",", migrationUnits.Select(x => x.DatabaseName + "." + x.CollectionName));

            MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob);

            Refresh(null);
        }
    }




    private void YesNoDialogSubmit(YesNoDialog.YesNoDialogResult result)
    {
        _yesNoDialogOpen = false;

        if (result.IsConfirmed)
        {     
            if (result.DiaLogType == YesNoDialog.Category.CutoverNot || result.DiaLogType == YesNoDialog.Category.CompleteNot)
            {
                MigrationJobContext.AddVerboseLog($"YesNoDialogSubmit {result.DiaLogType}");
                JobManager.StopMigration();                
                if (CurrentlyLoadedMigrationJob != null)
                {
                    CurrentlyLoadedMigrationJob.IsCancelled = true;
                    CurrentlyLoadedMigrationJob.IsCompleted = true;
                }

                if (MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob))
                    return;

                _refreshTimer = null;
            }
            else if (result.DiaLogType == YesNoDialog.Category.SyncBackNot)
            {
                //fire and forget
                if (CurrentlyLoadedMigrationJob != null)
                {
                     _ = Task.Run(async () =>
                    {
                        await JobManager.SyncBackToSource(MigrationJobContext.SourceConnectionString[MigrationJobContext.CurrentlyActiveJob.Id], MigrationJobContext.TargetConnectionString[MigrationJobContext.CurrentlyActiveJob.Id], MigrationJobContext.CurrentlyActiveJob);
                    });
                }
                if (MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob))
                    return;
            }
            else if( result.DiaLogType == YesNoDialog.Category.RunComparisonNot)
            {
                if (CurrentlyLoadedMigrationJob != null)
                {
                    CurrentlyLoadedMigrationJob.RunComparison = true;
                }
                if (MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob))
                    return;
            }

        }
        else
        {
            if (result.DiaLogType == YesNoDialog.Category.RunComparisonNot)
            {
                if (CurrentlyLoadedMigrationJob != null)
                {
                    CurrentlyLoadedMigrationJob.RunComparison = false;
                }
                if (MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob))
                    return;
            }
        }
    }

    private void PauseJobImmediate()
    {
        _errorMessage = string.Empty;
        JobManager.StopMigration();
        if (MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob))
            return;
        _refreshTimer = null;
    }

    private void PauseJobControlled()
    {
        _errorMessage = string.Empty;
        MigrationJobContext.RequestControlledPause("UI Button Click");

        if (MigrationJobContext.SaveMigrationJob(CurrentlyLoadedMigrationJob))
            return;
    }

    private async Task IncreaseDumpWorkers()
    {
        if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.CurrentDumpWorkers < 16)
        {
            int newCount = CurrentlyLoadedMigrationJob.CurrentDumpWorkers + 1;
            JobManager.AdjustDumpWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task DecreaseDumpWorkers()
    {
        if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.CurrentDumpWorkers > 1)
        {
            int newCount = CurrentlyLoadedMigrationJob.CurrentDumpWorkers - 1;
            JobManager.AdjustDumpWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task IncreaseRestoreWorkers()
    {
        if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.CurrentRestoreWorkers < 16)
        {
            int newCount = CurrentlyLoadedMigrationJob.CurrentRestoreWorkers + 1;
            JobManager.AdjustRestoreWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task DecreaseRestoreWorkers()
    {
        if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.CurrentRestoreWorkers > 1)
        {
            int newCount = CurrentlyLoadedMigrationJob.CurrentRestoreWorkers - 1;
            JobManager.AdjustRestoreWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task IncreaseInsertionWorkers()
    {
        if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.CurrentInsertionWorkers < 16)
        {
            int newCount = CurrentlyLoadedMigrationJob.CurrentInsertionWorkers + 1;
            JobManager.AdjustInsertionWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task DecreaseInsertionWorkers()
    {
        if (CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.CurrentInsertionWorkers > 1)
        {
            int newCount = CurrentlyLoadedMigrationJob.CurrentInsertionWorkers - 1;
            JobManager.AdjustInsertionWorkers(newCount);
            await InvokeAsync(StateHasChanged);
        }
    }

    private bool NoOtherActiveJobs()
    {        

        string activeJob = JobManager?.GetRunningJobId() ?? string.Empty;
        if (activeJob != string.Empty && activeJob != JobId)
        {
            var job = MigrationJobContext.GetMigrationJob(activeJob);
            if (job != null && !job.IsCancelled && !job.IsCompleted)
                return false;
            else
                return true;
        }
        else
            return true;
    }

    private  bool  IsPauseEnabled()
    {
        return CurrentlyLoadedMigrationJob != null && !CurrentlyLoadedMigrationJob.IsCancelled && !CurrentlyLoadedMigrationJob.IsCompleted && IsJobRunning() && NoOtherActiveJobs();
    }


    private bool IsResumeEnabled()
    {
        return CurrentlyLoadedMigrationJob != null && !CurrentlyLoadedMigrationJob.IsCompleted && !IsJobRunning();
    }

    private bool CanAutoStart()
    {
        
        if (IsResumeEnabled() && NoOtherActiveJobs() && CurrentlyLoadedMigrationJob != null && CurrentlyLoadedMigrationJob.IsStarted &&
            (!string.IsNullOrEmpty(MigrationJobContext.SourceConnectionString[CurrentlyLoadedMigrationJob.Id]) || !string.IsNullOrEmpty(MigrationJobContext.TargetConnectionString[CurrentlyLoadedMigrationJob.Id])))
        {
            return true;
        }
        return false;
    }

    public void Dispose()
    {
        _refreshTimer?.Dispose();
        _refreshTimer = null;
    }

    // Response model for log count API
    public class LogCountResponse
    {
        public int count { get; set; }
    }
}

@if (_showPaginatedDownloadDialog)
{
    <PaginatedDownloadDialog 
        TotalEntries="_logEntryCount" 
        JobId="@JobId"
        PageSize="@_config.LogPageSize"
        OnClose="ClosePaginatedDownloadDialog" />
}

